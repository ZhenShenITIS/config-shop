package tg.configshop;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ConfigShopApplicationTests {

    @Test
    void contextLoads() {
    }

}
package tg.configshop;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ConfigShopApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigShopApplication.class, args);
    }

}
package tg.configshop.dto;

import tg.configshop.model.BotUser;

import java.time.Instant;

public record ReferralWithProfitAndLevel(
        BotUser botUser,
        Long profit,
        Instant referredAt,
        int lvl
) {
}
package tg.configshop.dto;

import java.time.Instant;

public record ReferralProjection(
        Long userId,
        String firstName,
        Instant expireAt,
        Long profit,
        Instant referredAt,
        int lvl
) {}package tg.configshop.dto;

import tg.configshop.model.BotUser;

import java.time.Instant;

public record ReferralWithProfit (
        BotUser botUser,
        Long profit,
        Instant referredAt
) {
}
package tg.configshop.dto;

import java.time.Instant;

public interface ReferralView {
    Long getUserId();
    String getFirstName();
    Instant getExpireAt();
    Long getProfit();
    Instant getReferredAt();
    Integer getLvl();
}package tg.configshop.external_api.pay.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import tg.configshop.external_api.pay.constants.PaymentMethod;
import tg.configshop.external_api.pay.constants.PaymentStatus;

public record CreatePaymentResponse (
        String transactionId,
        PaymentMethod paymentMethod,
        String redirect,
        @JsonProperty("return")
        String returnUrl,
        String paymentDetails,
        PaymentStatus status,
        String expiresIn,
        String merchantId,
        Double usdtRate,
        Double cryptoAmount

) {
}
package tg.configshop.external_api.pay.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import tg.configshop.external_api.pay.constants.PaymentStatus;

@JsonIgnoreProperties(ignoreUnknown = true)
public record PaymentStatusResponse(
        String id,
        PaymentStatus status
) {

}
package tg.configshop.external_api.pay.dto;

public record PaymentDetails (
        Double amount,
        String currency
) {
}
package tg.configshop.external_api.pay.dto;

import com.fasterxml.jackson.annotation.JsonProperty;

public record CreatePaymentRequest (
        int paymentMethod,
        PaymentDetails paymentDetails,
        String description,
        @JsonProperty("return")
        String returnUrl,
        String failedUrl,
        String payload
) {
}
package tg.configshop.external_api.pay.converter;

import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;
import tg.configshop.external_api.pay.constants.PaymentMethod;

@Converter(autoApply = true)
public class PaymentMethodConverter implements AttributeConverter<PaymentMethod, String> {

    @Override
    public String convertToDatabaseColumn(PaymentMethod attribute) {
        if (attribute == null) {
            return null;
        }
        return attribute.getTextMethod();
    }

    @Override
    public PaymentMethod convertToEntityAttribute(String dbData) {
        if (dbData == null) {
            return null;
        }
        return PaymentMethod.fromTextMethod(dbData);
    }
}
package tg.configshop.external_api.pay.config;

import org.apache.hc.client5.http.config.RequestConfig;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.core5.util.Timeout;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestClient;

@Configuration
public class PlategaConfig {

    @Bean
    public RestClient plategaRestClient(@Value("${PAY_BASE_URL}") String apiUrl,
                                        @Value("${PAY_MERCHANT_ID}") String merchantId,
                                        @Value("${PAY_SECRET}") String apiToken)  {
        RequestConfig requestConfig = RequestConfig.custom()
                .setConnectTimeout(Timeout.ofSeconds(10))
                .setResponseTimeout(Timeout.ofSeconds(20))
                .build();
        CloseableHttpClient httpClient = HttpClients.custom()
                .setDefaultRequestConfig(requestConfig)
                .build();
        HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(httpClient);
        return RestClient.builder()
                .baseUrl(apiUrl)
                .defaultHeader("X-MerchantId", merchantId)
                .defaultHeader("X-Secret", apiToken)
                .defaultHeader("Content-Type", "application/json")
                .requestFactory(factory)
                .build();
    }
}
package tg.configshop.external_api.pay.constants;

public enum PaymentStatus {
    PENDING, CANCELED, CONFIRMED, CHARGEBACKED
}
package tg.configshop.external_api.pay.constants;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

@AllArgsConstructor
@Getter
public enum PaymentMethod {
    SBP("SBPQR", 2),
    CARD_RU("CardRu", 10),
    CARD("Card", 11),
    INTERNATIONAL("International", 12),
    CRYPTO("Crypto", 13);

    private final String textMethod;
    private final int intMethod;

    private static final Map<String, PaymentMethod> LOOKUP_MAP = new HashMap<>();

    static {
        for (PaymentMethod pm : values()) {
            LOOKUP_MAP.put(pm.textMethod, pm);
        }
    }
    public static PaymentMethod fromTextMethod(String textMethod) {
        return Optional.ofNullable(LOOKUP_MAP.get(textMethod))
                .orElseThrow(() -> new IllegalArgumentException("Unknown payment method: " + textMethod));
    }

    @JsonCreator
    public static PaymentMethod fromJson(String value) {
        return fromTextMethod(value);
    }

    @JsonValue
    public String toJson() {
        return this.textMethod;
    }
}
package tg.configshop.external_api.pay;

import tg.configshop.external_api.pay.constants.PaymentStatus;
import tg.configshop.external_api.pay.dto.CreatePaymentRequest;
import tg.configshop.external_api.pay.dto.CreatePaymentResponse;

public interface PlategaClient {
    CreatePaymentResponse createPayment(CreatePaymentRequest createPaymentRequest);
    PaymentStatus updateStatus(String paymentId);

}
package tg.configshop.external_api.pay;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestClient;
import tg.configshop.external_api.pay.constants.PaymentStatus;
import tg.configshop.external_api.pay.dto.CreatePaymentRequest;
import tg.configshop.external_api.pay.dto.CreatePaymentResponse;
import tg.configshop.external_api.pay.dto.PaymentStatusResponse;

@Component
@RequiredArgsConstructor
public class PlategaClientImpl implements PlategaClient {
    private final RestClient plategaRestClient;
    @Override
    public CreatePaymentResponse createPayment(CreatePaymentRequest createPaymentRequest) {
        return plategaRestClient.post()
                .uri("/transaction/process")
                .body(createPaymentRequest)
                .retrieve()
                .body(CreatePaymentResponse.class);
    }

    @Override
    public PaymentStatus updateStatus(String paymentId) {
        PaymentStatusResponse response = plategaRestClient.get()
                .uri("/transaction/{paymentId}", paymentId)
                .retrieve()
                .body(PaymentStatusResponse.class);
        return response.status();
    }
}
package tg.configshop.external_api.pay.repositories;

import jakarta.persistence.LockModeType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Lock;
import org.springframework.data.jpa.repository.Query;
import tg.configshop.external_api.pay.model.PlategaPayment;

import java.util.Optional;

public interface PlategaPaymentRepository extends JpaRepository<PlategaPayment, String> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT p FROM PlategaPayment p WHERE p.transactionId = :id")
    Optional<PlategaPayment> findByIdWithLock(String id);
}
package tg.configshop.external_api.pay.model;

import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import tg.configshop.external_api.pay.constants.PaymentMethod;
import tg.configshop.external_api.pay.constants.PaymentStatus;

@Entity
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "platega_payments")
public class PlategaPayment {
    @Id
    private String transactionId;
    private PaymentMethod paymentMethod;
    private String redirect;
    private String returnUrl;
    private String paymentDetails;
    private Double amount;
    private String currency;
    @Enumerated(EnumType.STRING)
    private PaymentStatus status;
    private Double usdtRate;
    private Double cryptoAmount;

}
package tg.configshop.external_api.remnawave.dto.user;

public record UserTraffic (
        Long usedTrafficBytes,
        Long lifetimeUsedTrafficBytes
) {
}
package tg.configshop.external_api.remnawave.dto.user;

import java.time.Instant;

public record RemnaveUserUpdateRequest (
        String uuid,
        Instant expireAt,
        Long trafficLimitBytes,
        Integer hwidDeviceLimit
){
}
package tg.configshop.external_api.remnawave.dto.user;

public record RemnawaveUserRootResponse(
        RemnawaveUserResponse response
) {
}
package tg.configshop.external_api.remnawave.dto.user;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.Builder;

import java.time.Instant;

@Builder
@JsonIgnoreProperties(ignoreUnknown = true)
public record RemnawaveUserResponse(
        String uuid,
        String username,
        Long telegramId,
        String shortUuid,
        Long trafficLimitBytes,
        Integer hwidDeviceLimit,
        UserTraffic userTraffic,
        Instant expireAt,
        String subscriptionUrl
) {
}
package tg.configshop.external_api.remnawave.dto.user;

import java.time.Instant;
import java.util.List;

public record RemnawaveUserRequest(
        String username,
        Instant expireAt,
        Long telegramId,
        Long trafficLimitBytes,
        Integer hwidDeviceLimit,
        List<String> activeInternalSquads
) {
}
package tg.configshop.external_api.remnawave.dto.squads;

public record InternalSquad(
        String uuid,
        String name
) {
}
package tg.configshop.external_api.remnawave.dto.squads;

import java.util.List;

public record InternalSquadsResponse (
        Integer total,
        List<InternalSquad> internalSquads
) {
}
package tg.configshop.external_api.remnawave.dto.squads;

public record InternalSquadsRootResponse (
        InternalSquadsResponse response
) {
}
package tg.configshop.external_api.remnawave.dto.device;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties(ignoreUnknown = true)
public record DeviceRootResponse(
        DeviceResponse response
) {
}
package tg.configshop.external_api.remnawave.dto.device;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.List;

@JsonIgnoreProperties(ignoreUnknown = true)
public record DeviceResponse(
        List<Device> devices,
        int total
) {
}
package tg.configshop.external_api.remnawave.dto.device;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.time.Instant;

/*
{
  "response": {
    "total": 1,
    "devices": [
      {
        "hwid": "string",
        "userUuid": "123e4567-e89b-12d3-a456-426614174000",
        "platform": null,
        "osVersion": null,
        "deviceModel": null,
        "userAgent": null,
        "createdAt": "2026-01-02T09:01:49.631Z",
        "updatedAt": "2026-01-02T09:01:49.631Z"
      }
    ]
  }
}
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public record Device(
        String hwid,
        String userUuid,
        String platform,
        String osVersion,
        String deviceModel,
        String userAgent,
        Instant createdAt,
        Instant updatedAt
) {
}
package tg.configshop.external_api.remnawave.config;

import org.apache.hc.client5.http.config.RequestConfig;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.core5.util.Timeout;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestClient;

import java.time.Duration;

@Configuration
public class RemnawaveConfig {
    @Bean
    public RestClient remnawaveRestClient(@Value("${CONFIG_PANEL_API_URL}") String apiUrl,
                                          @Value("${CONFIG_PANEL_API_KEY}") String apiToken)  {
        RequestConfig requestConfig = RequestConfig.custom()
                .setConnectTimeout(Timeout.ofSeconds(10))
                .setResponseTimeout(Timeout.ofSeconds(20))
                .build();
        CloseableHttpClient httpClient = HttpClients.custom()
                .setDefaultRequestConfig(requestConfig)
                .build();
        HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(httpClient);
        return RestClient.builder()
                .baseUrl(apiUrl)
                .defaultHeader("Authorization", "Bearer " + apiToken)
                .defaultHeader("Content-Type", "application/json")
                .requestFactory(factory)
                .build();
    }
}
package tg.configshop.external_api.remnawave;

import tg.configshop.external_api.remnawave.dto.device.Device;
import tg.configshop.external_api.remnawave.dto.user.RemnawaveUserResponse;

import java.time.Instant;
import java.util.List;

public interface RemnawaveClient {
    RemnawaveUserResponse createBasicUser (String username, Long telegramId);
    RemnawaveUserResponse getUser (String uuid);
    RemnawaveUserResponse updateSubscription (String uuid, Instant expireAt, Long trafficLimitBytes, Integer hwidDeviceLimit);
    List<Device> getUserDevices (String uuid);


}
package tg.configshop.external_api.remnawave;

import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestClient;
import tg.configshop.external_api.remnawave.dto.device.Device;
import tg.configshop.external_api.remnawave.dto.device.DeviceRootResponse;
import tg.configshop.external_api.remnawave.dto.squads.InternalSquad;
import tg.configshop.external_api.remnawave.dto.squads.InternalSquadsRootResponse;
import tg.configshop.external_api.remnawave.dto.user.RemnaveUserUpdateRequest;
import tg.configshop.external_api.remnawave.dto.user.RemnawaveUserRequest;
import tg.configshop.external_api.remnawave.dto.user.RemnawaveUserResponse;
import tg.configshop.external_api.remnawave.dto.user.RemnawaveUserRootResponse;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

@Component
@AllArgsConstructor
public class RemnawaveClientImpl implements RemnawaveClient {
    private final RestClient remnawaveRestClient;

    private final long TRIAL_PERIOD_IN_SECONDS = 432000;
    private final long TRIAL_TRAFFIC_IN_BYTES = 50L * 1024 * 1024 * 1024;
    private final int TRIAL_HWID_DEVICE_LIMIT = 2;

    @Override
    public RemnawaveUserResponse createBasicUser(String username, Long telegramId) {
        return remnawaveRestClient.post()
                .uri("/api/users")
                .body(new RemnawaveUserRequest(username, Instant.now().plusSeconds(TRIAL_PERIOD_IN_SECONDS), telegramId, TRIAL_TRAFFIC_IN_BYTES, TRIAL_HWID_DEVICE_LIMIT, getInternalSquads()))
                .retrieve()
                .body(RemnawaveUserRootResponse.class).response();
    }

    @Override
    public RemnawaveUserResponse getUser(String uuid) {
        return remnawaveRestClient.get()
                .uri("/api/users/{uuid}", uuid)
                .retrieve()
                .body(RemnawaveUserRootResponse.class)
                .response();
    }

    @Override
    public RemnawaveUserResponse updateSubscription(String uuid, Instant expireAt, Long trafficLimitBytes, Integer hwidDeviceLimit) {
        return remnawaveRestClient.patch()
                .uri("/api/users")
                .body(new RemnaveUserUpdateRequest(uuid, expireAt, trafficLimitBytes, hwidDeviceLimit))
                .retrieve()
                .body(RemnawaveUserRootResponse.class)
                .response();

    }

    @Override
    public List<Device> getUserDevices(String uuid) {
        return remnawaveRestClient.get()
                .uri("/api/hwid/devices/{uuid}", uuid)
                .retrieve()
                .body(DeviceRootResponse.class)
                .response()
                .devices();
    }

    private List<String> getInternalSquads() {
        List<InternalSquad> internalSquadList = remnawaveRestClient.get()
                .uri("/api/internal-squads")
                .retrieve()
                .body(InternalSquadsRootResponse.class)
                .response()
                .internalSquads();
        List<String> result = new ArrayList<>();
        for (InternalSquad is : internalSquadList) {
            if (!is.name().contains("serv")) {
                result.add(is.uuid());
            }
        }
        return result;
    }
}
package tg.configshop.util;

import javax.crypto.Cipher;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class RsaEncryptor {

    private static final String PUBLIC_KEY_PEM = "-----BEGIN PUBLIC KEY-----\n" + //
                "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA3UZ0M3L4K+WjM3vkbQnz\n" + //
                "ozHg/cRbEXvQ6i4A8RVN4OM3rK9kU01FdjyoIgywve8OEKsFnVwERZAQZ1Trv60B\n" + //
                "hmaM76QQEE+EUlIOL9EpwKWGtTL5lYC1sT9XJMNP3/CI0gP5wwQI88cY/xedpOEB\n" + //
                "W72EmOOShHUm/b/3m+HPmqwc4ugKj5zWV5SyiT829aFA5DxSjmIIFBAms7DafmSq\n" + //
                "LFTYIQL5cShDY2u+/sqyAw9yZIOoqW2TFIgIHhLPWek/ocDU7zyOrlu1E0SmcQQb\n" + //
                "LFqHq02fsnH6IcqTv3N5Adb/CkZDDQ6HvQVBmqbKZKf7ZdXkqsc/Zw27xhG7OfXC\n" + //
                "tUmWsiL7zA+KoTd3avyOh93Q9ju4UQsHthL3Gs4vECYOCS9dsXXSHEY/1ngU/hjO\n" + //
                "WFF8QEE/rYV6nA4PTyUvo5RsctSQL/9DJX7XNh3zngvif8LsCN2MPvx6X+zLouBX\n" + //
                "zgBkQ9DFfZAGLWf9TR7KVjZC/3NsuUCDoAOcpmN8pENBbeB0puiKMMWSvll36+2M\n" + //
                "YR1Xs0MgT8Y9TwhE2+TnnTJOhzmHi/BxiUlY/w2E0s4ax9GHAmX0wyF4zeV7kDkc\n" + //
                "vHuEdc0d7vDmdw0oqCqWj0Xwq86HfORu6tm1A8uRATjb4SzjTKclKuoElVAVa5Jo\n" + //
                "oh/uZMozC65SmDw+N5p6Su8CAwEAAQ==\n" + //
                "-----END PUBLIC KEY-----";
    private static final String HAPP_PREFIX = "happ://crypt4/";
    private static final int MAX_LEN = 450;

    public static String encryptAndBuildLink(String text) throws Exception {
        if (text == null) return null;

        text = text.trim();
        if (text.isEmpty()) return null;
        if (text.length() > MAX_LEN) return null;

        String base64 = encryptPKCS1v15(text);
        if (base64 == null) return null;

        return HAPP_PREFIX + base64;
    }

    private static String encryptPKCS1v15(String plainText) throws Exception {
        PublicKey publicKey = loadPublicKey(PUBLIC_KEY_PEM);

        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);

        byte[] encryptedBytes = cipher.doFinal(
                plainText.getBytes(StandardCharsets.UTF_8)
        );

        return Base64.getEncoder().encodeToString(encryptedBytes);
    }

    private static PublicKey loadPublicKey(String pem) throws Exception {
        String cleanPem = pem
                .replace("-----BEGIN PUBLIC KEY-----", "")
                .replace("-----END PUBLIC KEY-----", "")
                .replaceAll("\\s+", "");

        byte[] decoded = Base64.getDecoder().decode(cleanPem);

        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(decoded);
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");

        return keyFactory.generatePublic(keySpec);
    }
}
package tg.configshop.util;



import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;
import tg.configshop.model.Subscription;
import tg.configshop.repositories.SubscriptionRepository;
import tg.configshop.services.SubscriptionService;

import java.util.ArrayList;
import java.util.List;

@Component
@RequiredArgsConstructor
public class SubscriptionsInitializer implements CommandLineRunner {

    private final SubscriptionRepository subscriptionRepository;

    private final SubscriptionService subscriptionService;




    @Override
    public void run(String... args) {
        if (subscriptionRepository.count() > 0) {
            System.out.println("[Init] –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö —É–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–∞–ø–∏—Å–∏. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–ø—É—â–µ–Ω–∞.");
            return;
        }

        System.out.println("[Init] –ù–∞—á–∏–Ω–∞—é –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö —Ç–∞—Ä–∏—Ñ–∞–º–∏...");
        List<Subscription> subscriptions = new ArrayList<>();

        int[] monthsOptions = {1, 3, 6, 12};

        for (int months : monthsOptions) {
            int days = months * 30;
            for (int devices = subscriptionService.getMinDeviceCount(); devices <= subscriptionService.getMaxDeviceCount(); devices++) {
                Subscription sub = new Subscription();
                sub.setDurationDays(days);
                sub.setDeviceCount(devices);
                sub.setTrafficLimitGb(devices * subscriptionService.getTrafficLimitPerDevice());
                String periodName = switch (months) {
                    case 1 -> "1 –º–µ—Å—è—Ü";
                    case 12 -> "1 –≥–æ–¥";
                    case 6 -> "6 –º–µ—Å—è—Ü–µ–≤";
                    default -> months + " –º–µ—Å—è—Ü–∞";
                };
                sub.setName(String.format("%s (%d —É—Å—Ç—Ä.)", periodName, devices));

                long cost = calculateCost(days, devices);
                sub.setCost(cost);

                sub.setDescription("VPN –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ %s –¥–Ω–µ–π –∏ %s —É—Å—Ç—Ä–æ–π—Å—Ç–≤".formatted(days, devices));

                subscriptions.add(sub);
            }
        }

        subscriptionRepository.saveAll(subscriptions);
        System.out.println("[Init] –ì–æ—Ç–æ–≤–æ! –î–æ–±–∞–≤–ª–µ–Ω–æ " + subscriptions.size() + " —Ç–∞—Ä–∏—Ñ–æ–≤.");
    }

    private long calculateCost(int days, int devices) {
        long basePrice = subscriptionService.getBaseSubscriptionCostByDays(days);
        long extraPerDevice = subscriptionService.getExtraPricePerDeviceByDays(days);
        int extraDevices = devices - subscriptionService.getMinDeviceCount();
        if (extraDevices < 0) extraDevices = 0;
        return basePrice + (extraDevices * extraPerDevice);
    }
}
package tg.configshop.util;

public class StringUtil {
    public static String getSafeHtmlString (String unsafe) {
        return unsafe
                .replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;");
    }
}
package tg.configshop.util;

import org.telegram.telegrambots.meta.api.objects.message.Message;

public class MessageUtils {
    public static Long getReferrerId(Message message) {
        String[] parts = message.getText().split(" ");
        if (parts.length > 1) {
            String payload = parts[1];
            try {
                return Long.parseLong(payload);
            } catch (NumberFormatException e) {
                return null;
            }
        }
        return null;
    }
}
package tg.configshop.util;

import tg.configshop.model.BotUser;

import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

public class DateUtil {
    private final static DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("dd.MM.yyyy");
    private final static DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("dd.MM.yyyy HH:mm");

    public static boolean isExpired (BotUser botUser) {
        return botUser.getExpireAt().isBefore(Instant.now());
    }

    public static String getDateEndSubscription (BotUser botUser) {
        Instant date = botUser.getExpireAt();
        ZonedDateTime zdt = date.atZone(ZoneId.of("Europe/Moscow"));
        return zdt.format(dateTimeFormatter);
    }

    public static long getDaysLeft(BotUser botUser) {
        if (isExpired(botUser)) return 0;
        return java.time.Duration.between(Instant.now(), botUser.getExpireAt()).toDays();
    }

    public static String getPrettyDate (Instant date) {
        ZonedDateTime zdt = date.atZone(ZoneId.of("Europe/Moscow"));
        return zdt.format(dateFormatter);
    }

    public static String getPrettyDateWithTime (Instant date) {
        ZonedDateTime zdt = date.atZone(ZoneId.of("Europe/Moscow"));
        return zdt.format(dateTimeFormatter);
    }
}
package tg.configshop.config;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import lombok.AllArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.scheduling.annotation.EnableAsync;

import java.io.IOException;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;


@Configuration
@AllArgsConstructor
@EnableAsync
public class SpringConfig {

    private static final DateTimeFormatter INSTANT_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy HH:mm")
            .withZone(ZoneId.of("Europe/Moscow"));


    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();

        JavaTimeModule javaTimeModule = new JavaTimeModule();

        javaTimeModule.addSerializer(Instant.class, new JsonSerializer<Instant>() {
            @Override
            public void serialize(Instant value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
                gen.writeString(INSTANT_FORMATTER.format(value));
            }
        });

        mapper.registerModule(javaTimeModule);


        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);


        mapper.enable(SerializationFeature.INDENT_OUTPUT);

        return mapper;
    }
}package tg.configshop.constants;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum CallbackName {
    NONE("none"),
    // start-menu
    BALANCE("balance"),
    SUBSCRIPTION("subscription"),
    PROMO_CODE("promo_code"),
    REFERRAL("referral"),

    // balance
    HISTORY("history"),
    TOP_UP("top_up"),

    // referral
    REF_LIST("ref_list"),
    REF_ANALYTICS("ref_analytics"),

    BUY_SUB_MENU("buy_sub_menu"),

    WITHDRAW("withdraw"),

    BUY_PERIOD_30("buy_period_30"),
    BUY_PERIOD_90("buy_period_90"),
    BUY_PERIOD_180("buy_period_180"),
    BUY_PERIOD_360("buy_period_360"),

    CONFIRM_BUY("confirm_buy"),

    PURCHASE("pay"),

    DOCS_CONFIRM("docs_confirm"),

    DOCS_INFO("docs_info"),

    DOCS_DECLINE("docs_decline"),
    PAYMENT_SBP("payment_sbp"),
    PAYMENT_CRYPTO("payment_crypto"),

    CHECK_STATUS_SBP("check_sbp"),

    CRYPTO_WITHDRAWAL("crpt_with"),

    BACK_TO_MENU("back");

    private final String callbackName;

}
package tg.configshop.constants;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum ButtonText {
    BALANCE("üí∏ –ë–∞–ª–∞–Ω—Å: %s ‚ÇΩ"),
    PROMO_CODE("\uD83D\uDDDD –ü—Ä–æ–º–æ–∫–æ–¥"),//üóùÔ∏è
    REFERRAL("üë• –†–µ—Ñ–µ—Ä–∞–ª—ã"),
    SUPPORT("üë®‚Äçüîß –ü–æ–¥–¥–µ—Ä–∂–∫–∞"),
    SUBSCRIPTION("\uD83D\uDCC4 –ü–æ–¥–ø–∏—Å–∫–∞"), // üìÑ
    CONNECT("üîó –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è"),
    INSTRUCTION("üìë –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è"),
    HISTORY("üìú –ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π"),
    TOP_UP("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å"),
    BACK("üîô –ù–∞–∑–∞–¥"),
    REF_LIST("üë• –°–ø–∏—Å–æ–∫ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤"),
    REF_ANALYTICS("üìà –ê–Ω–∞–ª–∏—Ç–∏–∫–∞"),
    WITHDRAW("üì§ –í—ã–≤–æ–¥"),
    BUY_SUB("üí≥ –ü—Ä–æ–¥–ª–∏—Ç—å / –ö—É–ø–∏—Ç—å"),
    SUB_PERIOD_1_MONTH("üìÖ 1 –º–µ—Å—è—Ü ‚Äî %d ‚ÇΩ"),
    SUB_PERIOD_3_MONTH("üìÖ 3 –º–µ—Å—è—Ü–∞ ‚Äî %d ‚ÇΩ"),
    SUB_PERIOD_6_MONTH("üìÖ 6 –º–µ—Å—è—Ü–µ–≤ ‚Äî %d ‚ÇΩ"),
    SUB_PERIOD_12_MONTH("üìÖ 1 –≥–æ–¥ ‚Äî %d ‚ÇΩ"),
    DEVICE_OPTION_SELECTED("‚úÖ %d (%d ‚ÇΩ)"),
    DEVICE_OPTION_UNSELECTED("üîò %d (%d ‚ÇΩ)"),
    CONFIRM_PAYMENT("‚úÖ –û–ø–ª–∞—Ç–∏—Ç—å %d ‚ÇΩ"),
    CONFIRM_BUY("‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å"),
    INFO("‚ÑπÔ∏è–ò–Ω—Ñ–æ"),
    POLICY("–ü–æ–ª–∏—Ç–∏–∫–∞"),
    AGREEMENT("–°–æ–≥–ª–∞—à–µ–Ω–∏–µ"),
    BACK_PAGE("‚¨ÖÔ∏è"),
    FORWARD_PAGE("‚û°Ô∏è"),
    EMPTY("‚†Ä"),
    ACCEPT_RULES("‚úÖ –ü—Ä–∏–Ω–∏–º–∞—é"),
    DECLINE_RULES("‚ùå –û—Ç–∫–∞–∑–∞—Ç—å—Å—è"),
    PAYMENT_METHOD_SBP("üí† –°–ë–ü"),
    PAYMENT_METHOD_CRYPTO("üíé –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞"),
    PAY_ACTION("üí≥ –û–ø–ª–∞—Ç–∏—Ç—å"),
    CHECK_PAYMENT("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É"),
    BACK_TO_MENU("üîô –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é");

    private final String text;
}
package tg.configshop.constants;

public enum WithdrawalType {
    CARD, CRYPTO
}
package tg.configshop.constants;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum CommandName {
    UNKNOWN("null"),
    FIND_USER("/find_user"),
    BROADCAST("/broadcast"),
    START("/start");


    private final String commandName;

}
package tg.configshop.constants;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum DialogStageName {
    PROMO_CODE_INPUT("promo_input"),
    SBP_PAY("sbp_pay"),
    CRYPTO_WITHDRAW_SUM("crypto_wd_sum"),
    NONE("none");

    private final String dialogStageName;
}
package tg.configshop.constants;

public enum TopUpSource {
    REFERRAL, EXTERNAL, PROMO_CODE, ADMIN
}
package tg.configshop.constants;

public enum PaymentResult {
    PROCESSING, EXPIRED, CONFIRMED, CANCELED
}
package tg.configshop.constants;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum MessageText {
    START_TEXT_ACTIVE("""
                –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ–º, %s
                
                –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞ –¥–æ %s (–ú–°–ö)
                
                –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:
                """),
    START_TEXT_EXPIRED("""
            –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ–º, %s
            
            –£ –í–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç
            
            –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:
            """),
    BALANCE_MENU("""
            üí∞ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> %s ‚ÇΩ
            
            –ó–¥–µ—Å—å –í—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø–æ–ª–Ω–∏—Ç—å —Å—á–µ—Ç.
            """),

    CHOOSE_PAYMENT_METHOD("""
            üí≥ <b>–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞</b>
            
            –í—ã–±–µ—Ä–∏—Ç–µ —É–¥–æ–±–Ω—ã–π —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã:
            """),
    INPUT_SUM_PAYMENT("""
            üí∞ <b>–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è</b>
            
            –£–∫–∞–∂–∏—Ç–µ —Å—É–º–º—É –≤ —Ä—É–±–ª—è—Ö –æ–¥–Ω–∏–º —á–∏—Å–ª–æ–º.
            """),
    PAYMENT_DESCRIPTION("–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –∫–ª–∏–µ–Ω—Ç–∞ %s"),
    NUMBER_FORMAT_ERROR("""
            ‚ö†Ô∏è <b>–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–º–º—ã</b>
            
            –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –±–µ–∑ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–π –∏ –ª–∏—à–Ω–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤ (–ø—Ä–∏–º–µ—Ä: <code>1000</code>).
            """),
    SUM_PAY_ERROR("""
            ‚ö†Ô∏è <b>–ù–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è</b>
            
            –°—É–º–º–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ <b>%s‚Äì%s ‚ÇΩ</b>.
            """),
    SBP_PAYMENT_INSTRUCTION("""
            üí† <b>–û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ –°–ë–ü</b>
            
            üí∞ –°—É–º–º–∞: <b>%d ‚ÇΩ</b>
            üÜî ID —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: <code>%s</code>
            
            ‚ÑπÔ∏è <b>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:</b>
            1. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É <b>"–û–ø–ª–∞—Ç–∏—Ç—å"</b> –Ω–∏–∂–µ.
            2. –°–ª–µ–¥—É–π—Ç–µ —É–∫–∞–∑–∞–Ω–∏—è–º –ø–ª–∞—Ç–µ–∂–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã.
            3. –ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –≤–µ—Ä–Ω–∏—Ç–µ—Å—å –∫ –±–æ—Ç—É –∏ –Ω–∞–∂–º–∏—Ç–µ <b>"–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É"</b>.
            """),
    CONFIRMED_PAY("""
            ‚úÖ <b>–û–ø–ª–∞—Ç–∞ —É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞</b>
            
            –°—Ä–µ–¥—Å—Ç–≤–∞ –∑–∞—á–∏—Å–ª–µ–Ω—ã –Ω–∞ –í–∞—à –±–∞–ª–∞–Ω—Å.
            """),
    CANCELED_PAY("""
            ‚ùå <b>–û–ø–ª–∞—Ç–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞</b>
            
            –°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è —Å—Å—ã–ª–∫–∏ –∏—Å—Ç–µ–∫ –∏–ª–∏ –æ–ø–ª–∞—Ç–∞ –±—ã–ª–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.
            """),
    PROCESSING_PAY("""
            ‚è≥ –ü–ª–∞—Ç—ë–∂ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ
            
            –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É –ø–æ–∑–∂–µ (1‚Äì5 –º–∏–Ω—É—Ç).
            """),
    EXPIRED_PAY("""
            ‚ôªÔ∏è –ü–ª–∞—Ç—ë–∂ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω
            
            –î–∞–Ω–Ω–∞—è –æ–ø–ª–∞—Ç–∞ –±—ã–ª–∞ –∑–∞—á–∏—Å–ª–µ–Ω–∞ —Ä–∞–Ω–µ–µ.
            """),
    REFERRAL_MENU("""
            ü§ù <b>–ü–∞—Ä—Ç–Ω–µ—Ä—Å–∫–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞</b>
            
            üìä <b>–í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>
            ‚Ä¢ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: <b>%d</b>
            ‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: <b>%d</b>
            ‚Ä¢ –î–æ—Ö–æ–¥: <b>%d ‚ÇΩ</b>
            ‚Ä¢ –î–æ—Å—Ç—É–ø–Ω–æ –∫ –≤—ã–≤–æ–¥—É: <b>%d ‚ÇΩ</b>
            
            üè∑ <b>–í–∞—à –ø—Ä–æ–º–æ–∫–æ–¥:</b> <code>%s</code>
            
            ‚ÑπÔ∏è <b>–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?</b>
            1. –†–µ—Ñ–µ—Ä–∞–ª –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç –í–∞—à –ø—Ä–æ–º–æ–∫–æ–¥ –∏ –ø–æ–ª—É—á–∞–µ—Ç <b>100 ‚ÇΩ</b> –Ω–∞ –±–∞–ª–∞–Ω—Å.
            2. –†–µ—Ñ–µ—Ä–∞–ª –Ω–∞–≤—Å–µ–≥–¥–∞ –∑–∞–∫—Ä–µ–ø–ª—è–µ—Ç—Å—è –∑–∞ –í–∞–º–∏.
            3. –í—ã –ø–æ–ª—É—á–∞–µ—Ç–µ <b>%d%%</b> —Å –∫–∞–∂–¥–æ–≥–æ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –†–µ—Ñ–µ—Ä–∞–ª–∞.
            4. –ê —Ç–∞–∫–∂–µ <b>%d%%</b> –æ—Ç –†–µ—Ñ–µ—Ä–∞–ª–æ–≤ –≤–∞—à–µ–≥–æ –†–µ—Ñ–µ—Ä–∞–ª–∞ –∏ <b>%d%%</b> –æ—Ç –∏—Ö –†–µ—Ñ–µ—Ä–∞–ª–æ–≤!
            
            üîó <b>–í–∞—à–∞ –ø—Ä–∏–≥–ª–∞—Å–∏—Ç–µ–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:</b>
            <code>%s</code>
            """),
    REFERRAL_LIST("""
            üë• <b>–í–∞—à–∏ —Ä–µ—Ñ–µ—Ä–∞–ª—ã</b>
            
            <i>–°–ø–∏—Å–æ–∫ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω –≤ –ø–æ—Ä—è–¥–∫–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –æ—Ç –Ω–æ–≤—ã—Ö –∫ —Å—Ç–∞—Ä—ã–º</i>
            """),
    REFERRAL_LIST_EMPTY("""
            <i>–í–∞—à —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç...</i> üçÉ
            """),
    REFERRAL_INFO_ACTIVE("""
            üü¢ <b>%s</b>
            üì∂ –£—Ä–æ–≤–µ–Ω—å: %s
            üí∏ –î–æ—Ö–æ–¥ —Å —Ä–µ—Ñ–µ—Ä–∞–ª–∞: %s ‚ÇΩ
            üìÜ –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω: %s
            """),
    REFERRAL_INFO_INACTIVE("""
            üî¥ <b>%s</b>
            üì∂ –£—Ä–æ–≤–µ–Ω—å: %s
            üí∏ –î–æ—Ö–æ–¥ —Å —Ä–µ—Ñ–µ—Ä–∞–ª–∞: %s ‚ÇΩ
            üìÜ –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω: %s
            """),
    REFERRAL_REWARD_NOTIFICATION("""
            üí∏ <b>–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–µ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–µ!</b>
            
            –í–∞—à —Ä–µ—Ñ–µ—Ä–∞–ª %d-–≥–æ —É—Ä–æ–≤–Ω—è –ø–æ–ø–æ–ª–Ω–∏–ª –±–∞–ª–∞–Ω—Å –Ω–∞ —Å—É–º–º—É <b>%d ‚ÇΩ</b>
            –í–∞–º –∑–∞—á–∏—Å–ª–µ–Ω–æ <b>%.1f%%</b> —Å –µ–≥–æ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è
            
            üí∞ <b>–ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω –Ω–∞: %d ‚ÇΩ</b>
            """),
    WITHDRAWAL_METHOD("""
        üì§ <b>–í—ã–≤–æ–¥ —Å—Ä–µ–¥—Å—Ç–≤</b>
        
        –í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –≤—ã–≤–æ–¥–∞:
        """),
    CRYPTO_WITHDRAWAL_INPUT("""
        üíé <b>–í—ã–≤–æ–¥ –≤ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—É</b>
        
        üí∞ <b>–î–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –≤—ã–≤–æ–¥–∞:</b> %d ‚ÇΩ
        
        –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –≤—ã–≤–æ–¥–∞:
        """),
    SUBSCRIPTION("""
                üë§ <b>%s</b>
                üÜî <code>%s</code>
                üí∞ –ë–∞–ª–∞–Ω—Å: <b>%d ‚ÇΩ</b>
                
                üìã <b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ:</b>
                %s –ê–∫—Ç–∏–≤–Ω–∞ –¥–æ: <b>%s</b>
                ‚è≥ –û—Å—Ç–∞–ª–æ—Å—å: <b>%d –¥–Ω.</b>
                üìä –¢—Ä–∞—Ñ–∏–∫: <b>%.2f / %.2f –ì–ë</b>
                üì± –£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: <b>%d / %d</b>
                
                <blockquote><b>üîí –ü–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: </b>
                %s</blockquote>
                
                üîó <b>–ö–ª—é—á –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:</b>
                <pre><code class="–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å">%s</code></pre>
                """),
    EMPTY_DEVICES("<i>–£—Å—Ç—Ä–æ–π—Å—Ç–≤ –ø–æ–∫–∞ –Ω–µ—Ç. –ü–æ–¥–∫–ª—é—á–∏—Ç–µ –ø–µ—Ä–≤–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ.</i>"),
    PROMO_CODE_REQUEST("""
                üè∑ <b>–ê–∫—Ç–∏–≤–∞—Ü–∏—è –ø—Ä–æ–º–æ–∫–æ–¥–∞</b>
                
                –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –í–∞—à –ø—Ä–æ–º–æ–∫–æ–¥ –≤ —á–∞—Ç.
                """),

    PROMO_CODE_ALERT("""
            üè∑ <b>–û—Ç–ø—Ä–∞–≤—å—Ç–µ –ø—Ä–æ–º–æ–∫–æ–¥</b>
            
            –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –í–∞—à –ø—Ä–æ–º–æ–∫–æ–¥ –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º –≤ —á–∞—Ç.
            """),

    PROMO_SUCCESS("‚úÖ <b>–ü—Ä–æ–º–æ–∫–æ–¥ —É—Å–ø–µ—à–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!</b>\n–°—Ä–µ–¥—Å—Ç–≤–∞ –∑–∞—á–∏—Å–ª–µ–Ω—ã –Ω–∞ –í–∞—à –±–∞–ª–∞–Ω—Å"),

    PROMO_NOT_FOUND("‚ùå <b>–ü—Ä–æ–º–æ–∫–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω.</b>\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –≤–≤–æ–¥–∞"),

    PROMO_ALREADY_USED("‚ö†Ô∏è <b>–í—ã —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª–∏ —ç—Ç–æ—Ç –ø—Ä–æ–º–æ–∫–æ–¥</b>"),

    PROMO_ENDED("‚è≥ <b>–°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∏–ª–∏ –ª–∏–º–∏—Ç –∞–∫—Ç–∏–≤–∞—Ü–∏–π –∏—Å—á–µ—Ä–ø–∞–Ω</b>"),

    REFERRAL_PROMO_ALREADY_USED("üë• <b>–í—ã —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª–∏ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –ø—Ä–æ–º–æ–∫–æ–¥</b>"),

    CYCLIC_REFERRAL_EXCEPTION("üîÑ <b>–í—ã –ø—ã—Ç–∞–µ—Ç–µ—Å—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–æ–º–æ–∫–æ–¥ –∫–æ–≥–æ-—Ç–æ –∏–∑ —Å–≤–æ–∏—Ö —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤</b>"),

    SELF_REFERRAL_EXCEPTION("üåº <b>–ù–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –∫–æ–¥</b>"),

    PROMO_ERROR("‚ùå <b>–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏.</b>\n–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É"),

    BUY_SUBSCRIPTION_MENU_PERIOD("""
            üõí <b>–ü–æ–∫—É–ø–∫–∞ / –ü—Ä–æ–¥–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏</b>
            
            –í—ã–±–µ—Ä–∏—Ç–µ —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –≤–∞—à–µ–π –ø–æ–¥–ø–∏—Å–∫–∏:
            """),

    BUY_SUBSCRIPTION_MENU_DEVICE("""
            üõí <b>–ü–æ–∫—É–ø–∫–∞ / –ü—Ä–æ–¥–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏</b>
            
            –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤:
            """),

    CONFIRM_BUY_SUMMARY("""
            üìù <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ–∫—É–ø–∫–∏</b>
            
            üìÖ <b>–ü–µ—Ä–∏–æ–¥:</b> %s
            ‚ôæ <b>–¢—Ä–∞—Ñ–∏–∫:</b> –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π
            üì± <b>–£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞:</b> %d
            
            üí∞ <b>–î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–æ–∏–º–æ—Å—Ç–∏:</b>
            ‚Ä¢ –ë–∞–∑–æ–≤—ã–π —Ç–∞—Ä–∏—Ñ: <b>%d ‚ÇΩ</b>
            ‚Ä¢ –î–æ–ø. —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ (%d —à—Ç): <b>%d ‚ÇΩ</b>
            
            üíé <b>–ò—Ç–æ–≥–æ –∫ –æ–ø–ª–∞—Ç–µ:</b> %d ‚ÇΩ
            """),

    PURCHASE_SUCCESS("""
            ‚úÖ <b>–ü–æ–∫—É–ø–∫–∞ —É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞!</b>
            
            –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞. –ü—Ä–∏—è—Ç–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è!
            """),
    INSUFFICIENT_BALANCE("""
            ‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤</b>
            
            –î–ª—è –ø–æ–∫—É–ø–∫–∏ —ç—Ç–æ–≥–æ —Ç–∞—Ä–∏—Ñ–∞ –ø–æ–ø–æ–ª–Ω–∏—Ç–µ –í–∞—à –±–∞–ª–∞–Ω—Å.
            """),
    UNKNOWN_ERROR("""
            ‚ùå <b>–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞</b>
            
            –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.
            """),

    DOCS_DECLINE("""
            ‚ö†Ô∏è –î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –æ–≥—Ä–∞–Ω–∏—á–µ–Ω
            
            –í—ã –Ω–µ —Å–º–æ–∂–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º, –ø–æ–∫–∞ –Ω–µ –ø—Ä–∏–º–µ—Ç–µ —É—Å–ª–æ–≤–∏—è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—è –∏ –ü–æ–ª–∏—Ç–∏–∫–∏ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç–∏.
            """),

    REFERRAL_CREATED("""
            üë• <b>–ù–æ–≤—ã–π —Ä–µ—Ñ–µ—Ä–∞–ª!</b>
            
            <a href="tg://user?id=%s">%s</a> —Å—Ç–∞–ª –í–∞—à–∏–º —Ä–µ—Ñ–µ—Ä–∞–ª–æ–º!
            
            –¢–µ–ø–µ—Ä—å –í—ã –±—É–¥–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å –ø—Ä–∏–±—ã–ª—å —Å –∫–∞–∂–¥–æ–≥–æ –µ–≥–æ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è
            """),
    START_LEGAL_NOTICE("""
        üëã –ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, %s!
        
        –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø—Ä–∏–Ω—è—Ç—å —É—Å–ª–æ–≤–∏—è:
        1. <a href="%s">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ</a>
        2. <a href="%s">–ü–æ–ª–∏—Ç–∏–∫–∞ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç–∏</a>
        """ + "\n–ù–∞–∂–∏–º–∞—è –∫–Ω–æ–ø–∫—É <i>\"" + ButtonText.ACCEPT_RULES.getText() + "\",</i> –í—ã —Å–æ–≥–ª–∞—à–∞–µ—Ç–µ—Å—å —Å –ø—Ä–∞–≤–∏–ª–∞–º–∏ –°–µ—Ä–≤–∏—Å–∞."),

    LEGAL_TEXT("""
            1. <a href="%s">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ</a>
            2. <a href="%s">–ü–æ–ª–∏—Ç–∏–∫–∞ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç–∏</a>
            """),

    BROADCAST_USAGE("""
            ‚ùå <b>–ù–µ–≤–µ—Ä–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã</b>
            
            –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: <code>%s &lt;—Ç–µ–∫—Å—Ç –≤ HTML&gt;</code>
            """),

    BROADCAST_TEXT_NOT_FOUND("""
            ‚ùå <b>–û—à–∏–±–∫–∞</b>
            
            –¢–µ–∫—Å—Ç –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.
            """),

    BROADCAST_NO_USERS("""
            ‚ùå <b>–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É</b>
            
            –í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π.
            """),

    BROADCAST_START("""
            ‚úÖ <b>–ù–∞—á–∏–Ω–∞—é —Ä–∞—Å—Å—ã–ª–∫—É</b>
            
            –°–æ–æ–±—â–µ–Ω–∏–µ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ <b>%d</b> –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º...
            """),

    BROADCAST_REPORT("""
            üìä –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞:
            ‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: %d
            ‚ùå –û—à–∏–±–∫–∏: %d
            üö´ –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏: %d
            """),

    UNKNOWN_COMMAND("""
            ‚ùì <b>–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞</b>
            
            –ö–æ–º–∞–Ω–¥–∞ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∞, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤–≤–æ–¥ –∏–ª–∏ –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –º–µ–Ω—é.
            """);

    private final String messageText;

}
package tg.configshop.constants;

public enum WithdrawalStatus {
    REJECTED, DONE, IN_PROGRESS
}
package tg.configshop.repositories.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Repository;
import tg.configshop.repositories.UserStateRepository;
import tg.configshop.constants.DialogStageName;
import tg.configshop.telegram.dialogstages.impl.NoneDialogStage;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@RequiredArgsConstructor
@Repository
public class MapUserStateRepository implements UserStateRepository {
    private final Map<Long, DialogStageName> userStateMap = new ConcurrentHashMap<>();
    private final NoneDialogStage noneDialogStage;

    @Override
    public DialogStageName get(Long userId) {
        return userStateMap.getOrDefault(userId, noneDialogStage.getDialogStage());
    }

    @Override
    public void put(Long userId, DialogStageName dialogStageName) {
        userStateMap.put(userId, dialogStageName);
    }
}
package tg.configshop.repositories.impl;

import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Repository;
import tg.configshop.repositories.AdministratorRepository;

import java.util.ArrayList;
import java.util.List;

@Repository
public class ListAdministratorRepository implements AdministratorRepository {
    @Value("${ADMIN_IDS}")
    private String admins;

    private List<Long> adminList;

    @PostConstruct
    private void init () {
        String[] adminsStrings = admins.split(",");
        ArrayList<Long> adminList = new ArrayList<>();
        for (String s : adminsStrings) {
            try {
                adminList.add(Long.parseLong(s.trim()));
            } catch (NumberFormatException e) {
                throw new RuntimeException("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞: " + s, e);
            }
        }
        this.adminList = adminList;
    }


    @Override
    public boolean isAdmin(Long userId) {
        return adminList.contains(userId);
    }
}
package tg.configshop.repositories;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import tg.configshop.constants.TopUpSource;
import tg.configshop.model.TopUp;

public interface TopUpRepository extends JpaRepository<TopUp, Long> {
    @Query("""
        SELECT COALESCE(SUM(t.value), 0) 
        FROM TopUp t 
        WHERE t.botUser.id = :userId 
          AND t.topUpSource = :source
    """)
    Long getSumByUserIdAndSource(@Param("userId") Long userId, @Param("source") TopUpSource source);
}
package tg.configshop.repositories;

import jakarta.persistence.LockModeType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Lock;
import org.springframework.data.jpa.repository.Query;
import tg.configshop.model.BotUser;

import java.util.List;
import java.util.Optional;

public interface BotUserRepository extends JpaRepository<BotUser, Long> {
    List<BotUser> findByUsername(String username);

    List<BotUser> findByUsernameIgnoreCase(String username);

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT u FROM BotUser u WHERE u.id = :id")
    Optional<BotUser> findByIdWithLock(Long id);
}
package tg.configshop.repositories;

import org.springframework.data.jpa.repository.JpaRepository;
import tg.configshop.model.Subscription;

import java.util.Optional;

public interface SubscriptionRepository extends JpaRepository<Subscription, Long> {
    Optional<Subscription> findByDurationDaysAndDeviceCount(Integer durationDays, Integer deviceCount);
}
package tg.configshop.repositories;

import jakarta.persistence.LockModeType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Lock;
import org.springframework.data.jpa.repository.Query;
import tg.configshop.model.BotUser;
import tg.configshop.model.PromoCode;

import java.util.List;
import java.util.Optional;

public interface PromoCodeRepository extends JpaRepository<PromoCode, Long> {
    List<PromoCode> findAllByReferrer(BotUser referrer);

    Optional<PromoCode> findByCode(String code);

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT p FROM PromoCode p WHERE p.code = :code")
    Optional<PromoCode> findByCodeWithLock(String code);
}
package tg.configshop.repositories;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import tg.configshop.constants.TopUpSource;
import tg.configshop.dto.ReferralView;
import tg.configshop.dto.ReferralWithProfit;
import tg.configshop.model.BotUser;
import tg.configshop.model.Referral;

import java.time.Instant;
import java.util.List;
import java.util.Optional;

public interface ReferralRepository extends JpaRepository<Referral, Long> {
    int countReferralsByReferrer_Id(Long referrerId);

    @Query("""
    SELECT COUNT(r) 
    FROM Referral r 
    WHERE r.referrer.id = :referrerId 
      AND r.referral.expireAt > :now
""")
    int countActiveReferrals(@Param("referrerId") Long referrerId, @Param("now") Instant now);

    Optional<Referral> findByReferral_Id(Long referralId);

    @Query(value = """
        WITH RECURSIVE ancestors AS (
            SELECT referrer_id
            FROM referrals
            WHERE referral_id = :potentialReferrerId
            
            UNION ALL
            
            SELECT r.referrer_id
            FROM referrals r
            INNER JOIN ancestors a ON r.referral_id = a.referrer_id
        )
        SELECT COUNT(*) > 0 
        FROM ancestors 
        WHERE referrer_id = :currentUserId
        """, nativeQuery = true)
    boolean isUserAncestorOf(@Param("currentUserId") Long currentUserId,
                             @Param("potentialReferrerId") Long potentialReferrerId);




    @Query("""
                SELECT new tg.configshop.dto.ReferralWithProfit(
                    r.referral, 
                    CAST (COALESCE(SUM(tu.value), 0) AS LONG),
                    r.createdAt
                  
                )
                FROM Referral r
                LEFT JOIN TopUp tu 
                    ON tu.referral = r.referral 
                    AND tu.topUpSource = 'REFERRAL'
                WHERE r.referrer.id = :referrerId
                GROUP BY r.referral, r.createdAt
                ORDER BY r.createdAt DESC 
            """)
    Page<ReferralWithProfit> getReferralsWithProfit(
            @Param("referrerId") Long referrerId,
            Pageable pageable
    );

    @Query(value = """
        WITH RECURSIVE referral_tree AS (
        
            SELECT 
                r.referral_id        AS referral_id,
                r.created_at         AS referred_at,
                1                    AS lvl
            FROM referrals r
            WHERE r.referrer_id = :referrerId

            UNION ALL

        
            SELECT 
                r.referral_id        AS referral_id,
                r.created_at         AS referred_at,
                rt.lvl + 1           AS lvl
            FROM referrals r
            JOIN referral_tree rt ON r.referrer_id = rt.referral_id
            WHERE rt.lvl < 3
        )
        SELECT 
            b.id                          AS userId,
            b.first_name                  AS firstName,
            b.expire_at                   AS expireAt,
            rt.referred_at                AS referredAt,
            rt.lvl                        AS lvl,
            COALESCE(SUM(t.value), 0)     AS profit
        FROM referral_tree rt
        JOIN bot_users b ON rt.referral_id = b.id
        LEFT JOIN top_ups t 
            ON t.referral_id = rt.referral_id AND t.top_up_source = 'REFERRAL' AND t.bot_user_id = :referrerId
        GROUP BY b.id, b.first_name, b.expire_at, rt.referred_at, rt.lvl
        ORDER BY rt.lvl, rt.referred_at DESC
        """,
            countQuery = """
        WITH RECURSIVE referral_tree AS (
            
            SELECT 
                r.referral_id, 
                1 AS lvl 
            FROM referrals r
            WHERE r.referrer_id = :referrerId

            UNION ALL

        
            SELECT 
                r.referral_id, 
                rt.lvl + 1 
            FROM referrals r
            JOIN referral_tree rt ON r.referrer_id = rt.referral_id
            WHERE rt.lvl < 3
        )
        SELECT COUNT(*) FROM referral_tree
        """,
            nativeQuery = true)
    Page<ReferralView> findReferralsProjection(
            @Param("referrerId") Long referrerId,
            Pageable pageable
    );
}
package tg.configshop.repositories;

import org.springframework.data.jpa.repository.JpaRepository;
import tg.configshop.model.BotUser;
import tg.configshop.model.PromoCode;
import tg.configshop.model.PromoCodeUse;

public interface PromoCodeUseRepository extends JpaRepository<PromoCodeUse, Long> {
    boolean existsByPromoCodeAndBotUser(PromoCode promoCode, BotUser botUser);
    boolean existsByBotUserAndPromoCode_IsReferralTrue(BotUser botUser);
}
package tg.configshop.repositories;

import org.springframework.data.jpa.repository.JpaRepository;
import tg.configshop.model.Purchase;

public interface PurchaseRepository extends JpaRepository<Purchase, Long> {
}
package tg.configshop.repositories;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import tg.configshop.model.Withdrawal;

public interface WithdrawalRepository extends JpaRepository<Withdrawal, Long> {
    @Query("""
    SELECT COALESCE(SUM(w.amount), 0) 
    FROM Withdrawal w 
    WHERE w.botUser.id = :userId 
      AND w.status IN ('DONE', 'IN_PROGRESS')
    """)
    Long sumConsumedReferralBalance(@Param("userId") Long userId);
}
package tg.configshop.repositories;

public interface AdministratorRepository {
    boolean isAdmin (Long userId);
}
package tg.configshop.repositories;

import tg.configshop.constants.DialogStageName;

public interface UserStateRepository {
    DialogStageName get (Long userId);
    void put (Long userId, DialogStageName dialogStageName);
}
package tg.configshop.exceptions.subscription;

public class InsufficientBalanceException extends RuntimeException {
    public InsufficientBalanceException() {
    }

    public InsufficientBalanceException(String message) {
        super(message);
    }
}
package tg.configshop.exceptions.subscription;

public class SubscriptionNotFoundException extends RuntimeException {
    public SubscriptionNotFoundException(String message) {
        super(message);
    }

    public SubscriptionNotFoundException() {
    }
}
package tg.configshop.exceptions.promocode;

public class CyclicReferralException extends RuntimeException {
    public CyclicReferralException(String message) {
        super(message);
    }

    public CyclicReferralException() {
    }
}
package tg.configshop.exceptions.promocode;

public class ReferralPromoCodeAlreadyUsedException extends RuntimeException {
    public ReferralPromoCodeAlreadyUsedException(String message) {
        super(message);
    }

    public ReferralPromoCodeAlreadyUsedException() {
    }
}
package tg.configshop.exceptions.promocode;

public class PromoCodeEndedException extends RuntimeException {
    public PromoCodeEndedException(String message) {
        super(message);
    }

    public PromoCodeEndedException() {
    }
}
package tg.configshop.exceptions.promocode;

public class SelfReferralException extends RuntimeException {
    public SelfReferralException(String message) {
        super(message);
    }

    public SelfReferralException() {
    }
}
package tg.configshop.exceptions.promocode;

public class PromoCodeNotFoundException extends RuntimeException {
    public PromoCodeNotFoundException(String message) {
        super(message);
    }

    public PromoCodeNotFoundException() {
    }
}
package tg.configshop.exceptions.promocode;

public class PromoCodeAlreadyUsedException extends RuntimeException {
    public PromoCodeAlreadyUsedException(String message) {
        super(message);
    }

    public PromoCodeAlreadyUsedException() {
    }
}
package tg.configshop.aop;

import lombok.RequiredArgsConstructor;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import tg.configshop.repositories.AdministratorRepository;

@Aspect
@Component
@RequiredArgsConstructor
public class AdminAspect {

    private final AdministratorRepository administratorRepository;

    @Around("@annotation(adminOnly)")
    public Object validate (ProceedingJoinPoint joinPoint, AdminOnly adminOnly) throws Throwable {
        Object[] args = joinPoint.getArgs();

        if (args[0] instanceof CallbackQuery callbackQuery) {
            if (administratorRepository.isAdmin(callbackQuery.getFrom().getId())) {
                return joinPoint.proceed();
            }
        } else if (args[0] instanceof Message message) {
            if (administratorRepository.isAdmin(message.getFrom().getId())) {
                return joinPoint.proceed();
            }
        }
        return null;
    }
}
package tg.configshop.aop;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AdminOnly {
}
package tg.configshop.telegram.dto;

import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;

public record BotMessageParams(
        String text,
        InlineKeyboardMarkup inlineKeyboard
) {
}
package tg.configshop.telegram.config;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.experimental.FieldDefaults;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.client.okhttp.OkHttpTelegramClient;
import org.telegram.telegrambots.meta.generics.TelegramClient;

@Component
@Getter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class TelegramConfig {
    @Value("${TELEGRAM_BOT_USERNAME}")
    String botName;
    @Value("${TELEGRAM_BOT_TOKEN}")
    String botToken;

    @Bean
    public TelegramClient telegramClient () {
        return new OkHttpTelegramClient(getBotToken());
    }



}
package tg.configshop.telegram.callbacks.impl;

import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.telegram.callbacks.Callback;
import tg.configshop.constants.CallbackName;

@Component
public class NoneCallback implements Callback {
    private CallbackName callbackName = CallbackName.NONE;
    @Override
    public CallbackName getCallback() {
        return callbackName;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {

    }
}
package tg.configshop.telegram.callbacks.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.DialogStageName;
import tg.configshop.constants.MessageText;
import tg.configshop.repositories.UserStateRepository;
import tg.configshop.services.ReferralService;
import tg.configshop.telegram.callbacks.Callback;

import java.util.ArrayList;
import java.util.List;

@Component
@RequiredArgsConstructor
public class CryptoWithdrawalCallback implements Callback {
    private final ReferralService referralService;
    private final UserStateRepository userStateRepository;

    @Override
    public CallbackName getCallback() {
        return CallbackName.CRYPTO_WITHDRAWAL;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        long chatId = callbackQuery.getMessage().getChatId();
        int messageId = callbackQuery.getMessage().getMessageId();
        long userId = callbackQuery.getFrom().getId();

        long availableBalance = referralService.getAvailableSumToWithdraw(userId);

        List<InlineKeyboardRow> keyboard = new ArrayList<>();

        InlineKeyboardRow row = new InlineKeyboardRow();
        row.add(InlineKeyboardButton.builder()
                .text(ButtonText.BACK.getText())
                .callbackData(CallbackName.WITHDRAW.getCallbackName())
                .build());
        keyboard.add(row);

        InlineKeyboardMarkup markup = InlineKeyboardMarkup.builder()
                .keyboard(keyboard)
                .build();

        EditMessageText message = EditMessageText.builder()
                .chatId(chatId)
                .text(String.format(MessageText.CRYPTO_WITHDRAWAL_INPUT.getMessageText(), availableBalance))
                .replyMarkup(markup)
                .parseMode("HTML")
                .messageId(messageId)
                .build();


        try {
            telegramClient.execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
        userStateRepository.put(userId, DialogStageName.CRYPTO_WITHDRAW_SUM);
    }
}
package tg.configshop.telegram.callbacks.impl;


import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.CallbackName;
import tg.configshop.telegram.callbacks.Callback;

@Component
public class PaymentCryptoCallback implements Callback {
    @Override
    public CallbackName getCallback() {
        return CallbackName.PAYMENT_CRYPTO;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {

    }
}
package tg.configshop.telegram.callbacks.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.AnswerCallbackQuery;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.constants.PaymentResult;
import tg.configshop.services.PaymentService;
import tg.configshop.telegram.callbacks.Callback;

@Component
@RequiredArgsConstructor
public class CheckStatusSbpCallback implements Callback {
    public static final String PAYLOAD_SEPARATOR = ":";
    private final PaymentService paymentService;

    @Override
    public CallbackName getCallback() {
        return CallbackName.CHECK_STATUS_SBP;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        long userId = callbackQuery.getFrom().getId();
        long chatId = callbackQuery.getMessage().getChatId();
        int messageId = callbackQuery.getMessage().getMessageId();
        String callbackId = callbackQuery.getId();
        String data = callbackQuery.getData();

        String[] parts = data.split(PAYLOAD_SEPARATOR);

        if (parts.length < 2) {
            return;
        }

        String transactionId = parts[1];

        PaymentResult paymentResult = paymentService.checkPayment(transactionId, userId);


        switch (paymentResult) {
            case CONFIRMED ->
                    editMessage(chatId, messageId, MessageText.CONFIRMED_PAY.getMessageText(), telegramClient);
            case CANCELED ->
                    editMessage(chatId, messageId, MessageText.CANCELED_PAY.getMessageText(), telegramClient);
            case PROCESSING ->
                answerQuery(callbackId, MessageText.PROCESSING_PAY.getMessageText(), telegramClient);
            case EXPIRED ->
               answerQuery(callbackId, MessageText.EXPIRED_PAY.getMessageText(), telegramClient);

        }


    }

    private void editMessage(long chatId, int messageId, String text, TelegramClient telegramClient) {
        EditMessageText editMessageText = EditMessageText
                .builder()
                .text(text)
                .chatId(chatId)
                .replyMarkup(InlineKeyboardMarkup
                        .builder()
                        .keyboardRow(new InlineKeyboardRow(
                                InlineKeyboardButton
                                        .builder()
                                        .text(ButtonText.BACK_TO_MENU.getText())
                                        .callbackData(CallbackName.BACK_TO_MENU.getCallbackName())
                                        .build()

                        ))
                        .build())
                .messageId(messageId)
                .build();
        try {
            telegramClient.execute(editMessageText);
        } catch (TelegramApiException e) {
            throw new RuntimeException(e);
        }
    }

    private void answerQuery (String callbackId, String text, TelegramClient telegramClient) {
        AnswerCallbackQuery answerCallbackQuery = AnswerCallbackQuery
                .builder()
                .text(text)
                .callbackQueryId(callbackId)
                .showAlert(true)
                .build();
        try {
            telegramClient.execute(answerCallbackQuery);
        } catch (TelegramApiException e) {
            throw new RuntimeException(e);
        }
    }
}
package tg.configshop.telegram.callbacks.impl;

import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.telegram.callbacks.Callback;

import java.util.ArrayList;
import java.util.List;

@Component
@RequiredArgsConstructor
public class TopUpCallback implements Callback {

    @Override
    public CallbackName getCallback() {
        return CallbackName.TOP_UP;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        Long chatId = callbackQuery.getMessage().getChatId();
        Integer messageId = callbackQuery.getMessage().getMessageId();

        List<InlineKeyboardRow> rows = new ArrayList<>();
        rows.add(new InlineKeyboardRow(
                InlineKeyboardButton.builder()
                        .text(ButtonText.PAYMENT_METHOD_SBP.getText())
                        .callbackData(CallbackName.PAYMENT_SBP.getCallbackName())
                        .build()
        ));
//        rows.add(new InlineKeyboardRow(
//                InlineKeyboardButton.builder()
//                        .text(ButtonText.PAYMENT_METHOD_CRYPTO.getText())
//                        .callbackData(CallbackName.PAYMENT_CRYPTO.getCallbackName())
//                        .build()
//        ));
        rows.add(new InlineKeyboardRow(
                InlineKeyboardButton.builder()
                        .text(ButtonText.BACK.getText())
                        .callbackData(CallbackName.BALANCE.getCallbackName())
                        .build()
        ));
        EditMessageText editMessage = EditMessageText.builder()
                .chatId(chatId)
                .messageId(messageId)
                .text(MessageText.CHOOSE_PAYMENT_METHOD.getMessageText())
                .parseMode("HTML")
                .replyMarkup(new InlineKeyboardMarkup(rows))
                .build();

        try {
            telegramClient.execute(editMessage);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks.impl;

import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.CallbackName;
import tg.configshop.telegram.callbacks.Callback;

@Component
public class RefAnalyticsCallback implements Callback {
    @Override
    public CallbackName getCallback() {
        return CallbackName.REF_ANALYTICS;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {

    }
}
package tg.configshop.telegram.callbacks.impl;

import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.AnswerCallbackQuery;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.telegram.callbacks.Callback;

@Component
public class DocsDeclineCallback implements Callback {
    @Override
    public CallbackName getCallback() {
        return CallbackName.DOCS_DECLINE;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        AnswerCallbackQuery answer = AnswerCallbackQuery.builder()
                .callbackQueryId(callbackQuery.getId())
                .text(MessageText.DOCS_DECLINE.getMessageText())
                .showAlert(true)
                .build();

        try {
            telegramClient.execute(answer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks.impl;

import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.CallbackName;
import tg.configshop.telegram.callbacks.Callback;

@Component
public class HistoryCallback implements Callback {
    @Override
    public CallbackName getCallback() {
        return CallbackName.HISTORY;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {

    }
}
package tg.configshop.telegram.callbacks.impl.subscription;

import org.springframework.stereotype.Component;
import tg.configshop.constants.CallbackName;
import tg.configshop.services.SubscriptionService;

@Component
public class BuyPeriod30Callback extends AbstractBuyPeriodCallback {

    public BuyPeriod30Callback(SubscriptionService subscriptionService) {
        super(subscriptionService);
    }

    @Override
    public CallbackName getCallback() {
        return CallbackName.BUY_PERIOD_30;
    }

    @Override
    protected int getDaysPeriod() {
        return 30;
    }
}
package tg.configshop.telegram.callbacks.impl.subscription;

import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.services.SubscriptionService;
import tg.configshop.telegram.callbacks.Callback;

import java.util.ArrayList;
import java.util.List;

public abstract class AbstractBuyPeriodCallback implements Callback {

    protected final SubscriptionService subscriptionService;

    private static final String PAYLOAD_SEPARATOR = ":";

    public AbstractBuyPeriodCallback(SubscriptionService subscriptionService) {
        this.subscriptionService = subscriptionService;
    }

    protected abstract int getDaysPeriod();

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        String data = callbackQuery.getData();
        int selectedDevices = parseDevicesFromCallback(data);

        Long chatId = callbackQuery.getMessage().getChatId();
        Integer messageId = callbackQuery.getMessage().getMessageId();
        EditMessageText editMessageText = EditMessageText.builder()
                .chatId(chatId)
                .messageId(messageId)
                .text(MessageText.BUY_SUBSCRIPTION_MENU_DEVICE.getMessageText())
                .replyMarkup(createDeviceSelectionKeyboard(selectedDevices))
                .parseMode("HTML")
                .build();
        try {
            telegramClient.execute(editMessageText);

        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private int parseDevicesFromCallback(String data) {
        if (data.contains(PAYLOAD_SEPARATOR)) {
            try {
                return Integer.parseInt(data.split(PAYLOAD_SEPARATOR)[1]);
            } catch (NumberFormatException e) {
                e.printStackTrace();
            }
        }
        return subscriptionService.getMinDeviceCount();
    }

    private InlineKeyboardMarkup createDeviceSelectionKeyboard(int selectedDevices) {
        List<InlineKeyboardRow> rows = new ArrayList<>();
        List<InlineKeyboardButton> currentRowButtons = new ArrayList<>();

        int min = subscriptionService.getMinDeviceCount();
        int max = subscriptionService.getMaxDeviceCount();
        int days = getDaysPeriod();
        int basePrice = subscriptionService.getBaseSubscriptionCostByDays(days);
        int extraPrice = subscriptionService.getExtraPricePerDeviceByDays(days);

        for (int devices = min; devices <= max; devices++) {
            boolean isSelected = (devices == selectedDevices);

            int extraDevsCount = Math.max(0, devices - min);
            long totalPrice = basePrice + (long) extraDevsCount * extraPrice;

            String text;
            if (isSelected) {
                text = ButtonText.DEVICE_OPTION_SELECTED.getText().formatted(devices, totalPrice);
            } else {
                text = ButtonText.DEVICE_OPTION_UNSELECTED.getText().formatted(devices, totalPrice);
            }

            String callbackPayload = getCallback().getCallbackName() + PAYLOAD_SEPARATOR + devices;

            currentRowButtons.add(InlineKeyboardButton.builder()
                    .text(text)
                    .callbackData(callbackPayload)
                    .build());

            if (currentRowButtons.size() == 2) {
                rows.add(new InlineKeyboardRow(currentRowButtons));
                currentRowButtons = new ArrayList<>();
            }
        }

        if (!currentRowButtons.isEmpty()) {
            rows.add(new InlineKeyboardRow(currentRowButtons));
        }


        String confirmPayload = CallbackName.CONFIRM_BUY.getCallbackName() + PAYLOAD_SEPARATOR + days + PAYLOAD_SEPARATOR + selectedDevices;

        rows.add(new InlineKeyboardRow(
                InlineKeyboardButton.builder()
                        .text(ButtonText.CONFIRM_BUY.getText())
                        .callbackData(confirmPayload)
                        .build()
        ));

        rows.add(new InlineKeyboardRow(
                InlineKeyboardButton.builder()
                        .text(ButtonText.BACK.getText())
                        .callbackData(CallbackName.BUY_SUB_MENU.getCallbackName())
                        .build()
        ));

        return new InlineKeyboardMarkup(rows);
    }
}
package tg.configshop.telegram.callbacks.impl.subscription;

import org.springframework.stereotype.Component;
import tg.configshop.constants.CallbackName;
import tg.configshop.services.SubscriptionService;

@Component
public class BuyPeriod90Callback extends AbstractBuyPeriodCallback {

    public BuyPeriod90Callback(SubscriptionService subscriptionService) {
        super(subscriptionService);
    }

    @Override
    public CallbackName getCallback() {
        return CallbackName.BUY_PERIOD_90;
    }

    @Override
    protected int getDaysPeriod() {
        return 90;
    }
}
package tg.configshop.telegram.callbacks.impl.subscription;

import org.springframework.stereotype.Component;
import tg.configshop.constants.CallbackName;
import tg.configshop.services.SubscriptionService;

@Component
public class BuyPeriod180Callback extends AbstractBuyPeriodCallback {
    public BuyPeriod180Callback(SubscriptionService subscriptionService) {
        super(subscriptionService);
    }

    public CallbackName getCallback() {
        return CallbackName.BUY_PERIOD_180;
    }
    @Override
    protected int getDaysPeriod() {
        return 180;
    }
}
package tg.configshop.telegram.callbacks.impl.subscription;

import org.springframework.stereotype.Component;
import tg.configshop.constants.CallbackName;
import tg.configshop.services.SubscriptionService;

@Component
public class BuyPeriod360Callback extends AbstractBuyPeriodCallback {
    public BuyPeriod360Callback(SubscriptionService subscriptionService) {
        super(subscriptionService);
    }

    @Override
    public CallbackName getCallback() {
        return CallbackName.BUY_PERIOD_360;
    }


    @Override
    protected int getDaysPeriod() {
        return 360;
    }
}
package tg.configshop.telegram.callbacks.impl.subscription;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.exceptions.subscription.InsufficientBalanceException;
import tg.configshop.services.SubscriptionService;
import tg.configshop.telegram.callbacks.Callback;

@Component
@RequiredArgsConstructor
public class PurchaseCallback implements Callback {

    private final SubscriptionService subscriptionService;
    private static final String PAYLOAD_SEPARATOR = ":";

    @Value("${SUPPORT_USERNAME}")
    private String supportUsername;

    @Override
    public CallbackName getCallback() {
        return CallbackName.PURCHASE;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        String data = callbackQuery.getData();
        Long userId = callbackQuery.getFrom().getId();
        Long chatId = callbackQuery.getMessage().getChatId();
        Integer messageId = callbackQuery.getMessage().getMessageId();

        String[] parts = data.split(PAYLOAD_SEPARATOR);
        if (parts.length < 2) {
            sendUnknownError(telegramClient, chatId, messageId);
            return;
        }

        Long subscriptionId;
        try {
            subscriptionId = Long.parseLong(parts[1]);
        } catch (NumberFormatException e) {
            sendUnknownError(telegramClient, chatId, messageId);
            return;
        }

        try {
            subscriptionService.buySubscription(userId, subscriptionId);
            sendSuccessMessage(telegramClient, chatId, messageId);
        } catch (InsufficientBalanceException e) {
            sendInsufficientBalanceMessage(telegramClient, chatId, messageId);
        } catch (Exception e) {
            sendUnknownError(telegramClient, chatId, messageId);
        }
    }

    private void sendSuccessMessage(TelegramClient client, Long chatId, Integer messageId) {
        InlineKeyboardMarkup keyboard = InlineKeyboardMarkup.builder()
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.BACK_TO_MENU.getText())
                                .callbackData(CallbackName.BACK_TO_MENU.getCallbackName())
                                .build()
                ))
                .build();

        editMessage(client, chatId, messageId, MessageText.PURCHASE_SUCCESS.getMessageText(), keyboard);
    }

    private void sendInsufficientBalanceMessage(TelegramClient client, Long chatId, Integer messageId) {
        InlineKeyboardMarkup keyboard = InlineKeyboardMarkup.builder()
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.TOP_UP.getText())
                                .callbackData(CallbackName.TOP_UP.getCallbackName()) // –ó–∞–≥–ª—É—à–∫–∞, –∫–∞–∫ —Ç—ã –ø—Ä–æ—Å–∏–ª
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.BACK_TO_MENU.getText())
                                .callbackData(CallbackName.BACK_TO_MENU.getCallbackName())
                                .build()
                ))
                .build();

        editMessage(client, chatId, messageId, MessageText.INSUFFICIENT_BALANCE.getMessageText(), keyboard);
    }

    private void sendUnknownError(TelegramClient client, Long chatId, Integer messageId) {

        InlineKeyboardMarkup keyboard = InlineKeyboardMarkup.builder()
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.SUPPORT.getText())
                                .url("https://t.me/" + supportUsername)
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.BACK_TO_MENU.getText())
                                .callbackData(CallbackName.BACK_TO_MENU.getCallbackName())
                                .build()
                ))
                .build();

        editMessage(client, chatId, messageId, MessageText.UNKNOWN_ERROR.getMessageText(), keyboard);
    }

    private void editMessage(TelegramClient client, Long chatId, Integer messageId, String text, InlineKeyboardMarkup markup) {
        try {
            client.execute(EditMessageText.builder()
                    .chatId(chatId)
                    .messageId(messageId)
                    .text(text)
                    .parseMode("HTML")
                    .replyMarkup(markup)
                    .build());
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks.impl.subscription;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.external_api.remnawave.RemnawaveClient;
import tg.configshop.external_api.remnawave.dto.device.Device;
import tg.configshop.external_api.remnawave.dto.user.RemnawaveUserResponse;
import tg.configshop.model.BotUser;
import tg.configshop.services.UserService;
import tg.configshop.telegram.callbacks.Callback;
import tg.configshop.util.DateUtil;
import tg.configshop.util.RsaEncryptor;

import java.util.List;
import java.util.stream.Collectors;

@Component
@RequiredArgsConstructor
public class SubscriptionCallback implements Callback {
    private final CallbackName callbackName = CallbackName.SUBSCRIPTION;
    private final UserService userService;
    private final RemnawaveClient remnawaveClient;

    @Value("${CONFIG_PANEL_SUB_URL}")
    private String subUrl;

    @Value("${INSTRUCTION_URL}")
    private String instructionUrl;

    @Override
    public CallbackName getCallback() {
        return callbackName;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        Long userId = callbackQuery.getFrom().getId();
        BotUser botUser = userService.getUser(userId);

        // TODO refactor from "client -> view" to "client -> service -> view"
        List<Device> devices = remnawaveClient.getUserDevices(botUser.getRemnawaveUuid());
        RemnawaveUserResponse remoteUser = remnawaveClient.getUser(botUser.getRemnawaveUuid());
        int maxDevices = remoteUser.hwidDeviceLimit();

        double usedTrafficGb = remoteUser.userTraffic().usedTrafficBytes() / (1024.0 * 1024 * 1024);
        double limitTrafficGb = remoteUser.trafficLimitBytes() / (1024.0 * 1024 * 1024);

        userService.syncRemnawaveUserWithLocalUser(remoteUser, botUser);

        String devicesText;
        if (devices.isEmpty()) {
            devicesText = MessageText.EMPTY_DEVICES.getMessageText();
        } else {
            devicesText = devices.stream()
                    .map(device -> String.format("‚Ä¢ %s ‚Äî %s", device.platform(), device.deviceModel()))
                    .collect(Collectors.joining("\n"));
        }

        String statusEmoji = DateUtil.isExpired(botUser) ? "üî¥" : "üü¢";
        String dateEnd = DateUtil.getDateEndSubscription(botUser);
        long daysLeft = DateUtil.getDaysLeft(botUser);
        String subLink = null;
        try {
            subLink = RsaEncryptor.encryptAndBuildLink(subUrl + "/" + botUser.getShortId());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        String text = MessageText.SUBSCRIPTION.getMessageText().formatted(
                callbackQuery.getFrom().getFirstName(),
                botUser.getId(),
                botUser.getBalance(),
                statusEmoji, dateEnd, daysLeft,
                usedTrafficGb, limitTrafficGb,
                devices.size(), maxDevices,
                devicesText,
                subLink
        ).replace("/ 0.00", "/ ‚àû");


        InlineKeyboardMarkup markup = InlineKeyboardMarkup.builder()
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.INSTRUCTION.getText())
                                .url(instructionUrl)
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.BUY_SUB.getText())
                                .callbackData(CallbackName.BUY_SUB_MENU.getCallbackName()) // –ó–∞–≥–ª—É—à–∫–∞
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.BACK.getText())
                                .callbackData(CallbackName.BACK_TO_MENU.getCallbackName())
                                .build()
                ))
                .build();

        EditMessageText editMessage = EditMessageText.builder()
                .chatId(callbackQuery.getMessage().getChatId())
                .messageId(callbackQuery.getMessage().getMessageId())
                .text(text)
                .replyMarkup(markup)
                .parseMode("HTML")
                .disableWebPagePreview(true)
                .build();

        try {
            telegramClient.execute(editMessage);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks.impl.subscription;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.services.SubscriptionService;
import tg.configshop.telegram.callbacks.Callback;

@Component
@RequiredArgsConstructor
public class BuySubMenuCallback implements Callback {

    private final SubscriptionService subscriptionService;

    @Override
    public CallbackName getCallback() {
        return CallbackName.BUY_SUB_MENU;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        Long chatId = callbackQuery.getMessage().getChatId();
        Integer messageId = callbackQuery.getMessage().getMessageId();

        InlineKeyboardMarkup keyboard = InlineKeyboardMarkup.builder()
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.SUB_PERIOD_1_MONTH.getText().formatted(
                                        subscriptionService.getBaseSubscriptionCostByDays(30)
                                ))
                                .callbackData(CallbackName.BUY_PERIOD_30.getCallbackName())
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.SUB_PERIOD_3_MONTH.getText().formatted(
                                        subscriptionService.getBaseSubscriptionCostByDays(90)
                                ))
                                .callbackData(CallbackName.BUY_PERIOD_90.getCallbackName())
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.SUB_PERIOD_6_MONTH.getText().formatted(
                                        subscriptionService.getBaseSubscriptionCostByDays(180)
                                ))
                                .callbackData(CallbackName.BUY_PERIOD_180.getCallbackName())
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.SUB_PERIOD_12_MONTH.getText().formatted(
                                        subscriptionService.getBaseSubscriptionCostByDays(360)
                                ))
                                .callbackData(CallbackName.BUY_PERIOD_360.getCallbackName())
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.BACK.getText())
                                .callbackData(CallbackName.SUBSCRIPTION.getCallbackName()) // –í–µ–¥–µ–º –Ω–∞–∑–∞–¥ –≤ –º–µ–Ω—é –ø–æ–¥–ø–∏—Å–∫–∏
                                .build()
                ))
                .build();

        EditMessageText editMessage = EditMessageText.builder()
                .chatId(chatId)
                .messageId(messageId)
                .text(MessageText.BUY_SUBSCRIPTION_MENU_PERIOD.getMessageText())
                .parseMode("HTML")
                .replyMarkup(keyboard)
                .build();

        try {
            telegramClient.execute(editMessage);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks.impl.subscription;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.model.Subscription;
import tg.configshop.services.SubscriptionService;
import tg.configshop.telegram.callbacks.Callback;


@Component
@RequiredArgsConstructor
public class ConfirmBuyCallback implements Callback {

    private final SubscriptionService subscriptionService;
    private static final String PAYLOAD_SEPARATOR = ":";

    @Override
    public CallbackName getCallback() {
        return CallbackName.CONFIRM_BUY;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        String data = callbackQuery.getData();

        String[] parts = data.split(PAYLOAD_SEPARATOR);

        if (parts.length < 3) {
            return;
        }

        int days;
        int devices;

        try {
            days = Integer.parseInt(parts[1]);
            devices = Integer.parseInt(parts[2]);
        } catch (NumberFormatException e) {
            return;
        }


        Subscription subscription = subscriptionService.getSubscriptionByDaysAndDevices(days, devices);


        int minDevices = subscriptionService.getMinDeviceCount();
        int basePrice = subscriptionService.getBaseSubscriptionCostByDays(days);

        int extraDevicesCount = Math.max(0, devices - minDevices);
        int extraPricePerUnit = subscriptionService.getExtraPricePerDeviceByDays(days);
        int totalExtraPrice = extraDevicesCount * extraPricePerUnit;

        long finalPrice = subscription.getCost();

        String periodText = formatPeriod(days);

        String summaryText = MessageText.CONFIRM_BUY_SUMMARY.getMessageText().formatted(
                periodText,
                devices,
                basePrice,
                extraDevicesCount,
                totalExtraPrice,
                finalPrice
        );

        Long chatId = callbackQuery.getMessage().getChatId();
        Integer messageId = callbackQuery.getMessage().getMessageId();

        String backCallbackData = getBackCallbackNameByDays(days) + PAYLOAD_SEPARATOR + devices;

        String payCallbackData = CallbackName.PURCHASE.getCallbackName() + PAYLOAD_SEPARATOR + subscription.getId();

        InlineKeyboardMarkup keyboard = InlineKeyboardMarkup.builder()
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.CONFIRM_PAYMENT.getText().formatted(finalPrice))
                                .callbackData(payCallbackData)
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.BACK.getText())
                                .callbackData(backCallbackData)
                                .build()
                ))
                .build();

        EditMessageText editMessage = EditMessageText.builder()
                .chatId(chatId)
                .messageId(messageId)
                .text(summaryText)
                .parseMode("HTML")
                .replyMarkup(keyboard)
                .build();

        try {
            telegramClient.execute(editMessage);
        } catch (TelegramApiException e) {
        }
    }

    private String getBackCallbackNameByDays(int days) {
        return switch (days) {
            case 30 -> CallbackName.BUY_PERIOD_30.getCallbackName();
            case 90 -> CallbackName.BUY_PERIOD_90.getCallbackName();
            case 180 -> CallbackName.BUY_PERIOD_180.getCallbackName();
            case 360 -> CallbackName.BUY_PERIOD_360.getCallbackName();
            default -> CallbackName.BUY_SUB_MENU.getCallbackName();
        };
    }

    private String formatPeriod(int days) {
        return switch (days) {
            case 30 -> "1 –º–µ—Å—è—Ü";
            case 90 -> "3 –º–µ—Å—è—Ü–∞";
            case 180 -> "6 –º–µ—Å—è—Ü–µ–≤";
            case 360 -> "1 –≥–æ–¥";
            default -> days + " –¥–Ω–µ–π";
        };
    }
}
package tg.configshop.telegram.callbacks.impl;

import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.telegram.callbacks.Callback;

import java.util.ArrayList;
import java.util.List;

@Component
public class WithdrawalCallback implements Callback {
    @Override
    public CallbackName getCallback() {
        return CallbackName.WITHDRAW;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        long chatId = callbackQuery.getMessage().getChatId();
        int messageId = callbackQuery.getMessage().getMessageId();

        List<InlineKeyboardRow> keyboard = new ArrayList<>();

        InlineKeyboardRow row1 = new InlineKeyboardRow();
        row1.add(InlineKeyboardButton.builder()
                .text(ButtonText.PAYMENT_METHOD_CRYPTO.getText())
                .callbackData(CallbackName.CRYPTO_WITHDRAWAL.getCallbackName())
                .build());
        keyboard.add(row1);

        InlineKeyboardRow row2 = new InlineKeyboardRow();
        row2.add(InlineKeyboardButton.builder()
                .text(ButtonText.BACK.getText())
                .callbackData(CallbackName.REFERRAL.getCallbackName())
                .build());
        keyboard.add(row2);

        InlineKeyboardMarkup markup = InlineKeyboardMarkup.builder()
                .keyboard(keyboard)
                .build();

        EditMessageText message = EditMessageText.builder()
                .chatId(chatId)
                .text(MessageText.WITHDRAWAL_METHOD.getMessageText())
                .replyMarkup(markup)
                .messageId(messageId)
                .parseMode("HTML")
                .build();

        try {
            telegramClient.execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.telegram.callbacks.Callback;
import tg.configshop.telegram.dto.BotMessageParams;
import tg.configshop.telegram.message_body.StartCommandBody;

@Component
@RequiredArgsConstructor
public class BackToMenuCallback implements Callback {
    private final StartCommandBody startCommandBody;
    @Override
    public CallbackName getCallback() {
        return CallbackName.BACK_TO_MENU;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        long chatId = callbackQuery.getMessage().getChatId();
        int messageId = callbackQuery.getMessage().getMessageId();

        BotMessageParams params = startCommandBody.getMessage(callbackQuery.getFrom(), null);
        EditMessageText editMessage = EditMessageText.builder()
                .chatId(chatId)
                .messageId(messageId)
                .text(params.text())
                .replyMarkup(params.inlineKeyboard())
                .parseMode("HTML")
                .build();

        try {
            telegramClient.execute(editMessage);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.model.BotUser;
import tg.configshop.services.ReferralService; // –¢–≤–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
import tg.configshop.services.UserService;
import tg.configshop.telegram.callbacks.Callback;

@Component
@RequiredArgsConstructor
public class ReferralCallback implements Callback {
    private final CallbackName callbackName = CallbackName.REFERRAL;
    private final ReferralService referralService;
    private final UserService userService;

    @Value("${TELEGRAM_BOT_USERNAME}")
    private String botUsername;

    @Value("${SUPPORT_USERNAME}")
    private String supportUsername;

    @Override
    public CallbackName getCallback() {
        return callbackName;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        long userId = callbackQuery.getFrom().getId();
        long chatId = callbackQuery.getMessage().getChatId();
        int messageId = callbackQuery.getMessage().getMessageId();

        int allCount = referralService.getAllReferralCount(userId);
        int activeCount = referralService.getActiveReferralCount(userId);
        long profit = referralService.getAllProfit(userId);
        long available = referralService.getAvailableSumToWithdraw(userId);
        String promoCode = referralService.getReferralPromoCode(userId);
        BotUser botUser = userService.getUser(userId);

        int lvl1 = botUser.getReferralPercentage1lvl();

        int lvl2 = botUser.getReferralPercentage2lvl();
        int lvl3 = botUser.getReferralPercentage3lvl();


        String refLink = String.format("https://t.me/%s?start=%d", botUsername, userId);

        String text = MessageText.REFERRAL_MENU.getMessageText().formatted(
                allCount,
                activeCount,
                profit,
                available,
                promoCode,
                lvl1,
                lvl2,
                lvl3,
                refLink
        );


        InlineKeyboardMarkup markup = InlineKeyboardMarkup.builder()
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.REF_LIST.getText())
                                .callbackData(CallbackName.REF_LIST.getCallbackName())
                                .build(),
                        InlineKeyboardButton.builder()
                                .text(ButtonText.WITHDRAW.getText())
                                .url("t.me/" + supportUsername)
                                // TODO
                                //.callbackData(CallbackName.WITHDRAW.getCallbackName())
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.BACK.getText())
                                .callbackData(CallbackName.BACK_TO_MENU.getCallbackName())
                                .build()
                ))
                .build();

        EditMessageText editMessage = EditMessageText.builder()
                .chatId(chatId)
                .messageId(messageId)
                .text(text)
                .replyMarkup(markup)
                .parseMode("HTML")
                .disableWebPagePreview(true)
                .build();

        try {
            telegramClient.execute(editMessage);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.dto.ReferralWithProfit;
import tg.configshop.dto.ReferralWithProfitAndLevel;
import tg.configshop.model.BotUser;
import tg.configshop.services.ReferralService;
import tg.configshop.telegram.callbacks.Callback;
import tg.configshop.util.DateUtil;

import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

@Component
@RequiredArgsConstructor
public class RefListCallback implements Callback {

    private final ReferralService referralService;

    private static final String PAYLOAD_SEPARATOR = ":";

    @Override
    public CallbackName getCallback() {
        return CallbackName.REF_LIST;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        Long userId = callbackQuery.getFrom().getId();
        String data = callbackQuery.getData();


        int pageNumber = 0;
        if (data.contains(PAYLOAD_SEPARATOR)) {
            try {
                pageNumber = Integer.parseInt(data.split(PAYLOAD_SEPARATOR)[1]);
            } catch (NumberFormatException ignored) {
            }
        }


        Page<ReferralWithProfitAndLevel> page = referralService.getReferralsWithProfitAndLevel(userId, pageNumber);

        String text;
        List<InlineKeyboardRow> rows = new ArrayList<>();


        if (page.isEmpty()) {

            text = MessageText.REFERRAL_LIST_EMPTY.getMessageText();
        } else {

            StringBuilder sb = new StringBuilder();

            sb.append(MessageText.REFERRAL_LIST.getMessageText()).append("\n");

            for (ReferralWithProfitAndLevel item : page.getContent()) {
                BotUser ref = item.botUser();

                String template = DateUtil.isExpired(ref)
                        ? MessageText.REFERRAL_INFO_INACTIVE.getMessageText()
                        : MessageText.REFERRAL_INFO_ACTIVE.getMessageText();

                String dateStr = DateUtil.getPrettyDate(item.referredAt());

                String name = ref.getFirstName();

                sb.append(String.format(template, name, item.lvl(), item.profit(), dateStr)).append("\n\n");
            }
            text = sb.toString();



            if (page.getTotalPages() > 1) {
                InlineKeyboardRow paginationRow = new InlineKeyboardRow();

                if (page.hasPrevious()) {
                    paginationRow.add(InlineKeyboardButton.builder()
                            .text(ButtonText.BACK_PAGE.getText())
                            .callbackData(CallbackName.REF_LIST.getCallbackName() + PAYLOAD_SEPARATOR + (page.getNumber() - 1))
                            .build());
                } else {
                    paginationRow.add(InlineKeyboardButton.builder()
                            .text(ButtonText.EMPTY.getText())
                            .callbackData(CallbackName.NONE.getCallbackName())
                            .build());
                }

                paginationRow.add(InlineKeyboardButton.builder()
                        .text(String.format("%d/%d", page.getNumber() + 1, page.getTotalPages()))
                        .callbackData(CallbackName.NONE.getCallbackName())
                        .build());

                if (page.hasNext()) {
                    paginationRow.add(InlineKeyboardButton.builder()
                            .text(ButtonText.FORWARD_PAGE.getText())
                            .callbackData(CallbackName.REF_LIST.getCallbackName() + PAYLOAD_SEPARATOR + (page.getNumber() + 1))
                            .build());
                } else {
                    paginationRow.add(InlineKeyboardButton.builder()
                            .text(ButtonText.EMPTY.getText())
                            .callbackData(CallbackName.NONE.getCallbackName())
                            .build());
                }

                rows.add(paginationRow);
            }

        }

        rows.add(new InlineKeyboardRow(
                InlineKeyboardButton.builder()
                        .text(ButtonText.BACK.getText())
                        .callbackData(CallbackName.REFERRAL.getCallbackName())
                        .build()
        ));

        EditMessageText editMessage = EditMessageText.builder()
                .chatId(userId)
                .messageId(callbackQuery.getMessage().getMessageId())
                .text(text)
                .parseMode("HTML")
                .replyMarkup(new InlineKeyboardMarkup(rows))
                .build();

        try {
            telegramClient.execute(editMessage);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.DialogStageName;
import tg.configshop.constants.MessageText;
import tg.configshop.repositories.UserStateRepository;
import tg.configshop.telegram.callbacks.Callback;

@Component
@RequiredArgsConstructor
public class PaymentSbpCallback implements Callback {
    private final UserStateRepository userStateRepository;
    @Override
    public CallbackName getCallback() {
        return CallbackName.PAYMENT_SBP;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        long chatId = callbackQuery.getMessage().getChatId();
        int messageId = callbackQuery.getMessage().getMessageId();
        long userId = callbackQuery.getFrom().getId();

        userStateRepository.put(userId, DialogStageName.SBP_PAY);
        EditMessageText editMessageText = EditMessageText
                .builder()
                .text(MessageText.INPUT_SUM_PAYMENT.getMessageText())
                .chatId(chatId)
                .messageId(messageId)
                .parseMode("HTML")
                .replyMarkup(InlineKeyboardMarkup
                        .builder()
                        .keyboardRow(new InlineKeyboardRow(
                                InlineKeyboardButton
                                        .builder()
                                        .text(ButtonText.BACK.getText())
                                        .callbackData(CallbackName.TOP_UP.getCallbackName())
                                        .build()
                        ))
                        .build())
                .build();
        try {
            telegramClient.execute(editMessageText);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.DialogStageName;
import tg.configshop.constants.MessageText;
import tg.configshop.repositories.UserStateRepository;
import tg.configshop.telegram.callbacks.Callback;

@Component
@RequiredArgsConstructor
public class PromoCodeCallback implements Callback {
    private final CallbackName callbackName = CallbackName.PROMO_CODE;

    private final UserStateRepository stateRepository;

    @Override
    public CallbackName getCallback() {
        return callbackName;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        long chatId = callbackQuery.getMessage().getChatId();
        int messageId = callbackQuery.getMessage().getMessageId();
        long userId = callbackQuery.getFrom().getId();

        String text = MessageText.PROMO_CODE_REQUEST.getMessageText();

        InlineKeyboardMarkup markup = InlineKeyboardMarkup.builder()
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.BACK.getText())
                                .callbackData(CallbackName.BACK_TO_MENU.getCallbackName())
                                .build()
                ))
                .build();

        EditMessageText editMessage = EditMessageText.builder()
                .chatId(chatId)
                .messageId(messageId)
                .text(text)
                .replyMarkup(markup)
                .parseMode("HTML")
                .build();

        try {
            telegramClient.execute(editMessage);
        } catch (Exception e) {
            e.printStackTrace();
        }
        stateRepository.put(userId, DialogStageName.PROMO_CODE_INPUT);

    }
}
package tg.configshop.telegram.callbacks.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.model.BotUser;
import tg.configshop.services.UserService;
import tg.configshop.telegram.callbacks.Callback;

@Component
@RequiredArgsConstructor
public class BalanceCallback implements Callback {
    private final CallbackName callbackName = CallbackName.BALANCE;
    private final UserService userService;

    @Override
    public CallbackName getCallback() {
        return callbackName;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        long chatId = callbackQuery.getMessage().getChatId();
        int messageId = callbackQuery.getMessage().getMessageId();
        long userId = callbackQuery.getFrom().getId();

        BotUser botUser = userService.getUser(userId);
        String balance = botUser.getBalance().toString();

        EditMessageText editMessage = EditMessageText.builder()
                .chatId(chatId)
                .messageId(messageId)
                .text(MessageText.BALANCE_MENU.getMessageText().formatted(balance))
                .parseMode("HTML")
                .replyMarkup(InlineKeyboardMarkup.builder()
                        .keyboardRow(new InlineKeyboardRow(
                                // TODO Operation History
//                                InlineKeyboardButton.builder()
//                                        .text(ButtonText.HISTORY.getText())
//                                        .callbackData(CallbackName.HISTORY.getCallbackName())
//                                        .build(),
                                InlineKeyboardButton.builder()
                                        .text(ButtonText.TOP_UP.getText())
                                        .callbackData(CallbackName.TOP_UP.getCallbackName())
                                        .build()
                        ))
                        .keyboardRow(new InlineKeyboardRow(
                                InlineKeyboardButton.builder()
                                        .text(ButtonText.BACK.getText())
                                        .callbackData(CallbackName.BACK_TO_MENU.getCallbackName())
                                        .build()
                        ))
                        .build())
                .build();

        try {
            telegramClient.execute(editMessage);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.CallbackName;
import tg.configshop.services.RegistrationService;
import tg.configshop.telegram.callbacks.Callback;
import tg.configshop.telegram.dto.BotMessageParams;
import tg.configshop.telegram.message_body.StartCommandBody;

@Component
@RequiredArgsConstructor
public class DocsConfirmCallback implements Callback {
    private final RegistrationService registrationService;
    private final StartCommandBody startCommandBody;
    @Override
    public CallbackName getCallback() {
        return CallbackName.DOCS_CONFIRM;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        Long referrerId = null;
        if (callbackQuery.getData().contains(":")) {
            referrerId = Long.parseLong(callbackQuery.getData().split(":")[1]);
        }
        registrationService.registerUser(callbackQuery.getFrom(), referrerId);
        BotMessageParams botMessageParams = startCommandBody.getMessage(callbackQuery.getFrom(), referrerId);
        EditMessageText editMessageText = EditMessageText
                .builder()
                .text(botMessageParams.text())
                .messageId(callbackQuery.getMessage().getMessageId())
                .chatId(callbackQuery.getMessage().getChatId())
                .replyMarkup(botMessageParams.inlineKeyboard())
                .parseMode("HTML")
                .build();

        try {
            telegramClient.execute(editMessageText);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks.impl;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.telegram.callbacks.Callback;

@Component
public class InfoCallback implements Callback {

    @Value("${AGREEMENT_URL}")
    private String agreementUrl;

    @Value("${POLICY_URL}")
    private String policyUrl;

    @Override
    public CallbackName getCallback() {
        return CallbackName.DOCS_INFO;
    }

    @Override
    public void processCallback(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        long chatId = callbackQuery.getMessage().getChatId();
        int messageId = callbackQuery.getMessage().getMessageId();

        String text = MessageText.LEGAL_TEXT.getMessageText().formatted(agreementUrl, policyUrl);

        InlineKeyboardMarkup markup = InlineKeyboardMarkup.builder()
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.BACK.getText())
                                .callbackData(CallbackName.BACK_TO_MENU.getCallbackName())
                                .build()
                ))
                .build();

        EditMessageText editMessage = EditMessageText.builder()
                .chatId(chatId)
                .messageId(messageId)
                .text(text)
                .replyMarkup(markup)
                .parseMode("HTML")
                .build();

        try {
            telegramClient.execute(editMessage);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.callbacks;

import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.CallbackName;


public interface Callback {
    CallbackName getCallback();
    void processCallback (CallbackQuery callbackQuery, TelegramClient telegramClient);

}
package tg.configshop.telegram.message_body;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.objects.User;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.MessageText;
import tg.configshop.model.BotUser;
import tg.configshop.services.RegistrationService;
import tg.configshop.services.UserService;
import tg.configshop.telegram.dto.BotMessageParams;
import tg.configshop.util.DateUtil;
import tg.configshop.util.StringUtil;

@Component
@RequiredArgsConstructor
public class StartCommandBody {
    private final RegistrationService registrationService;
    private final UserService userService;

    @Value("${CONFIG_PANEL_SUB_URL}")
    private String subUrl;

    @Value("${SUPPORT_USERNAME}")
    private String supportUsername;

    @Value("${AGREEMENT_URL}")
    private String agreementUrl;

    @Value("${POLICY_URL}")
    private String policyUrl;



    public BotMessageParams getMessage (User user, Long referrerId) {
        long userId = user.getId();
        BotUser botUser;
        if (!registrationService.isRegistered(userId)) {
            return getLegalAgreementMessage(user.getFirstName(), referrerId);
        } else {
            botUser = userService.getUser(userId);
        }

        String firstName = StringUtil.getSafeHtmlString(user.getFirstName());

        String text = DateUtil.isExpired(botUser) ?
                MessageText.START_TEXT_EXPIRED.getMessageText().formatted(firstName)
                :
                MessageText.START_TEXT_ACTIVE.getMessageText().formatted(firstName, DateUtil.getDateEndSubscription(botUser));

        InlineKeyboardMarkup keyboard = InlineKeyboardMarkup
                .builder()
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton
                                .builder()
                                .text(ButtonText.CONNECT.getText())
                                .url(subUrl+"/"+botUser.getShortId())
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton
                                .builder()
                                .text(ButtonText.BALANCE.getText().formatted(botUser.getBalance()))
                                .callbackData(CallbackName.BALANCE.getCallbackName())
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton
                                .builder()
                                .text(ButtonText.SUBSCRIPTION.getText())
                                .callbackData(CallbackName.SUBSCRIPTION.getCallbackName())
                                .build(),
                        InlineKeyboardButton
                                .builder()
                                .text(ButtonText.PROMO_CODE.getText())
                                .callbackData(CallbackName.PROMO_CODE.getCallbackName())
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton
                                .builder()
                                .text(ButtonText.REFERRAL.getText())
                                .callbackData(CallbackName.REFERRAL.getCallbackName())
                                .build(),
                        InlineKeyboardButton
                                .builder()
                                .text(ButtonText.SUPPORT.getText())
                                .url("t.me/" + supportUsername)
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton
                                .builder()
                                .text(ButtonText.INFO.getText())
                                .callbackData(CallbackName.DOCS_INFO.getCallbackName())
                                .build()
                ))
                .build();

        return new BotMessageParams(text, keyboard);

    }

    private BotMessageParams getLegalAgreementMessage(String firstName, Long referrerId) {

        String text = MessageText.START_LEGAL_NOTICE.getMessageText()
                .formatted(firstName, agreementUrl, policyUrl);
        String confirmCallbackData = CallbackName.DOCS_CONFIRM.getCallbackName();
        if (referrerId != null) {
            confirmCallbackData += ":" + referrerId;
        }

        InlineKeyboardMarkup keyboard = InlineKeyboardMarkup.builder()
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.ACCEPT_RULES.getText())
                                .callbackData(confirmCallbackData)
                                .build()
                ))
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.DECLINE_RULES.getText())
                                .callbackData(CallbackName.DOCS_DECLINE.getCallbackName())
                                .build()
                ))
                .build();

        return new BotMessageParams(text, keyboard);
    }

}
package tg.configshop.telegram.bot;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.client.okhttp.OkHttpTelegramClient;
import org.telegram.telegrambots.longpolling.interfaces.LongPollingUpdateConsumer;
import org.telegram.telegrambots.longpolling.starter.SpringLongPollingBot;
import org.telegram.telegrambots.longpolling.util.LongPollingSingleThreadUpdateConsumer;
import org.telegram.telegrambots.meta.api.objects.Update;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.telegram.config.TelegramConfig;
import tg.configshop.telegram.handlers.CallbackQueryHandler;
import tg.configshop.telegram.handlers.MessageHandler;


@Component
@RequiredArgsConstructor
public class ShopBot implements SpringLongPollingBot, LongPollingSingleThreadUpdateConsumer {

    private final TelegramClient telegramClient;

    private final TelegramConfig telegramConfig;

    private final CallbackQueryHandler callbackQueryHandler;

    private final MessageHandler messageHandler;



    @Override
    public void consume(Update update) {
        Thread.startVirtualThread(() -> consumeUpdate(update));
    }

    @Override
    public String getBotToken() {
        return telegramConfig.getBotToken();
    }

    @Override
    public LongPollingUpdateConsumer getUpdatesConsumer() {
        return this;
    }

    private void consumeUpdate(Update update) {
        if (update.hasCallbackQuery()) {
            callbackQueryHandler.processCallbackQuery(update.getCallbackQuery(), telegramClient);
        } else if (update.hasMessage()) {
            messageHandler.answerMessage(update.getMessage(), telegramClient);

        }
    }
}package tg.configshop.telegram.dialogstages.impl;

import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.DialogStageName;
import tg.configshop.telegram.dialogstages.DialogStage;

@Component
public class NoneDialogStage implements DialogStage {
    DialogStageName dialogStageName = DialogStageName.NONE;
    @Override
    public DialogStageName getDialogStage() {
        return dialogStageName;
    }

    @Override
    public void processCallbackQuery(CallbackQuery callbackQuery, TelegramClient telegramClient) {

    }

    @Override
    public void answerMessage(Message message, TelegramClient telegramClient) {

    }
}
package tg.configshop.telegram.dialogstages.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.AnswerCallbackQuery;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.DialogStageName;
import tg.configshop.constants.MessageText;
import tg.configshop.exceptions.promocode.CyclicReferralException;
import tg.configshop.exceptions.promocode.PromoCodeAlreadyUsedException;
import tg.configshop.exceptions.promocode.PromoCodeEndedException;
import tg.configshop.exceptions.promocode.PromoCodeNotFoundException;
import tg.configshop.exceptions.promocode.ReferralPromoCodeAlreadyUsedException;
import tg.configshop.exceptions.promocode.SelfReferralException;
import tg.configshop.repositories.UserStateRepository;
import tg.configshop.services.PromoCodeService;
import tg.configshop.telegram.callbacks.impl.BackToMenuCallback;
import tg.configshop.telegram.dialogstages.DialogStage;

@RequiredArgsConstructor
@Component
public class PromoCodeInputDialogStage implements DialogStage {
    private final PromoCodeService promoCodeService;
    private final UserStateRepository stateRepository;
    private final BackToMenuCallback backToMenuCallback;

    @Override
    public DialogStageName getDialogStage() {
        return DialogStageName.PROMO_CODE_INPUT;
    }

    @Override
    public void processCallbackQuery(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        if (CallbackName.BACK_TO_MENU.getCallbackName().equals(callbackQuery.getData())) {
            stateRepository.put(callbackQuery.getFrom().getId(), DialogStageName.NONE);
            backToMenuCallback.processCallback(callbackQuery, telegramClient);
            return;
        }
        AnswerCallbackQuery answer = AnswerCallbackQuery.builder()
                .callbackQueryId(callbackQuery.getId())
                .text(MessageText.PROMO_CODE_ALERT.getMessageText())
                .showAlert(false)
                .build();

        try {
            telegramClient.execute(answer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void answerMessage(Message message, TelegramClient telegramClient) {
        long userId = message.getFrom().getId();
        String code = message.getText().trim();
        String responseText;

        try {

            promoCodeService.activatePromoCode(code, userId);
            responseText = MessageText.PROMO_SUCCESS.getMessageText();
            stateRepository.put(userId, DialogStageName.NONE);

        } catch (PromoCodeNotFoundException e) {
            responseText = MessageText.PROMO_NOT_FOUND.getMessageText();
        } catch (PromoCodeAlreadyUsedException e) {
            responseText = MessageText.PROMO_ALREADY_USED.getMessageText();
        } catch (PromoCodeEndedException e) {
            responseText = MessageText.PROMO_ENDED.getMessageText();
        } catch (ReferralPromoCodeAlreadyUsedException e) {
            responseText = MessageText.REFERRAL_PROMO_ALREADY_USED.getMessageText();
        } catch (CyclicReferralException e) {
            responseText = MessageText.CYCLIC_REFERRAL_EXCEPTION.getMessageText();
        } catch (SelfReferralException e) {
            responseText = MessageText.SELF_REFERRAL_EXCEPTION.getMessageText();
        } catch (Exception e) {
            responseText = MessageText.PROMO_ERROR.getMessageText();
            e.printStackTrace();
        }

        InlineKeyboardMarkup markup = InlineKeyboardMarkup.builder()
                .keyboardRow(new InlineKeyboardRow(
                        InlineKeyboardButton.builder()
                                .text(ButtonText.BACK.getText())
                                .callbackData(CallbackName.BACK_TO_MENU.getCallbackName())
                                .build()
                ))
                .build();

        SendMessage sendMessage = SendMessage.builder()
                .chatId(message.getChatId())
                .text(responseText)
                .replyMarkup(markup)
                .parseMode("HTML")
                .build();

        try {
            telegramClient.execute(sendMessage);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.telegram.dialogstages.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.AnswerCallbackQuery;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.ButtonText;
import tg.configshop.constants.CallbackName;
import tg.configshop.constants.DialogStageName;
import tg.configshop.constants.MessageText;
import tg.configshop.external_api.pay.constants.PaymentMethod;
import tg.configshop.external_api.pay.model.PlategaPayment;
import tg.configshop.repositories.UserStateRepository;
import tg.configshop.services.PaymentService;
import tg.configshop.telegram.callbacks.impl.TopUpCallback;
import tg.configshop.telegram.dialogstages.DialogStage;

import java.util.ArrayList;
import java.util.List;

@Component
@RequiredArgsConstructor
public class SbpPayStage implements DialogStage {
    private final UserStateRepository stateRepository;
    private final TopUpCallback topUpCallback;
    private final PaymentService paymentService;

    public static final String PAYLOAD_SEPARATOR = ":";
    public static final long MIN_PAY_AMOUNT = 100;
    public static final long MAX_PAY_AMOUNT = 10000;


    @Override
    public DialogStageName getDialogStage() {
        return DialogStageName.SBP_PAY;
    }

    @Override
    public void processCallbackQuery(CallbackQuery callbackQuery, TelegramClient telegramClient) {
        if (CallbackName.TOP_UP.getCallbackName().equals(callbackQuery.getData())) {
            stateRepository.put(callbackQuery.getFrom().getId(), DialogStageName.NONE);
            topUpCallback.processCallback(callbackQuery, telegramClient);
            return;
        }
        AnswerCallbackQuery answer = AnswerCallbackQuery.builder()
                .callbackQueryId(callbackQuery.getId())
                .text(MessageText.INPUT_SUM_PAYMENT.getMessageText())
                .showAlert(false)
                .build();

        try {
            telegramClient.execute(answer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void answerMessage(Message message, TelegramClient telegramClient) {
        long chatId = message.getChatId();
        long userId = message.getFrom().getId();
        long amount;
        try {
            amount = Long.parseLong(message.getText());
        } catch (NumberFormatException e) {
            sendNumberFormatError(chatId, telegramClient);
            return;
        }
        if (amount < MIN_PAY_AMOUNT || amount > MAX_PAY_AMOUNT) {
            sendSumError(chatId, telegramClient);
            return;
        }
        stateRepository.put(userId, DialogStageName.NONE);
        PlategaPayment plategaPayment = paymentService.createPlategaPayment(amount, PaymentMethod.SBP.getIntMethod(), userId);

        String shortId = plategaPayment.getTransactionId().split("-")[0];

        String text = String.format(MessageText.SBP_PAYMENT_INSTRUCTION.getMessageText(), amount, shortId);

        List<InlineKeyboardRow> rows = new ArrayList<>();

        InlineKeyboardButton payButton = InlineKeyboardButton.builder()
                .text(ButtonText.PAY_ACTION.getText())
                .url(plategaPayment.getRedirect())
                .build();
        rows.add(new InlineKeyboardRow(payButton));

        String checkPayload = CallbackName.CHECK_STATUS_SBP.getCallbackName()
                              + PAYLOAD_SEPARATOR
                              + plategaPayment.getTransactionId();

        InlineKeyboardButton checkButton = InlineKeyboardButton.builder()
                .text(ButtonText.CHECK_PAYMENT.getText())
                .callbackData(checkPayload)
                .build();
        rows.add(new InlineKeyboardRow(checkButton));

        InlineKeyboardButton backButton = InlineKeyboardButton.builder()
                .text(ButtonText.BACK.getText())
                .callbackData(CallbackName.TOP_UP.getCallbackName())
                .build();
        rows.add(new InlineKeyboardRow(backButton));

        SendMessage sendMessage = SendMessage.builder()
                .chatId(chatId)
                .text(text)
                .parseMode("HTML")
                .replyMarkup(new InlineKeyboardMarkup(rows))
                .build();

        try {
            telegramClient.execute(sendMessage);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }

    }

    private void sendNumberFormatError (long chatId, TelegramClient telegramClient) {
        SendMessage sendMessage = SendMessage
                .builder()
                .chatId(chatId)
                .text(MessageText.NUMBER_FORMAT_ERROR.getMessageText())
                .parseMode("HTML")
                .build();
        try {
            telegramClient.execute(sendMessage);
        } catch (TelegramApiException e) {
            throw new RuntimeException(e);
        }
    }

    private void sendSumError (long chatId, TelegramClient telegramClient) {
        SendMessage sendMessage = SendMessage
                .builder()
                .chatId(chatId)
                .text(MessageText.SUM_PAY_ERROR.getMessageText().formatted(MIN_PAY_AMOUNT, MAX_PAY_AMOUNT))
                .parseMode("HTML")
                .build();
        try {
            telegramClient.execute(sendMessage);
        } catch (TelegramApiException e) {
            throw new RuntimeException(e);
        }
    }
}
package tg.configshop.telegram.dialogstages.impl;

import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.DialogStageName;
import tg.configshop.telegram.dialogstages.DialogStage;

public class CryptoWithdrawSumInputStage implements DialogStage {
    @Override
    public DialogStageName getDialogStage() {
        return DialogStageName.CRYPTO_WITHDRAW_SUM;
    }

    @Override
    public void processCallbackQuery(CallbackQuery callbackQuery, TelegramClient telegramClient) {

    }

    @Override
    public void answerMessage(Message message, TelegramClient telegramClient) {

    }
}
package tg.configshop.telegram.dialogstages;

import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.DialogStageName;


public interface DialogStage {
    DialogStageName getDialogStage();
    void processCallbackQuery(CallbackQuery callbackQuery, TelegramClient telegramClient);
    void answerMessage(Message message, TelegramClient telegramClient);
}
package tg.configshop.telegram.commands.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.telegram.commands.Command;
import tg.configshop.constants.CommandName;
import tg.configshop.telegram.dto.BotMessageParams;
import tg.configshop.telegram.message_body.StartCommandBody;
import tg.configshop.util.MessageUtils;


@Component
@RequiredArgsConstructor
public class StartCommand implements Command {
    private final CommandName commandName = CommandName.START;
    private final StartCommandBody startCommandBody;

    @Override
    public CommandName getCommand() {
        return commandName;
    }

    @Override
    public void handleCommand(Message message, TelegramClient telegramClient) {
        BotMessageParams params = startCommandBody.getMessage(message.getFrom(), MessageUtils.getReferrerId(message));
        SendMessage sendMessage = SendMessage
                .builder()
                .chatId(message.getChatId())
                .replyMarkup(params.inlineKeyboard())
                .text(params.text())
                .parseMode("HTML")
                .build();
        try {
            telegramClient.execute(sendMessage);
        } catch (TelegramApiException e) {
            throw new RuntimeException(e);
        }
    }


}
package tg.configshop.telegram.commands.impl;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.aop.AdminOnly;
import tg.configshop.constants.CommandName;
import tg.configshop.model.BotUser;
import tg.configshop.services.UserService;
import tg.configshop.telegram.commands.Command;

import java.util.List;

@Component
@RequiredArgsConstructor
public class FindUserCommand implements Command {
    private final UserService userService;
    private final ObjectMapper objectMapper;

    @Override
    public CommandName getCommand() {
        return CommandName.FIND_USER;
    }

    @Override
    @AdminOnly
    public void handleCommand(Message message, TelegramClient telegramClient) {
        String textToSend;
        String msgPayload = message.getText().split(" ")[1];
        try {
            BotUser botUser = userService.getUser(Long.parseLong(msgPayload));
            textToSend = objectMapper.writeValueAsString(botUser);
        } catch (NumberFormatException e) {
            List<BotUser> botUsers = userService.getUser(msgPayload.replace("@", ""));
            try {
                textToSend = objectMapper.writeValueAsString(botUsers);
            } catch (JsonProcessingException ex) {
                textToSend = ex.toString();
            }
        } catch (JsonProcessingException e) {
            textToSend = e.toString();
        }

        long chatId = message.getChatId();
        SendMessage sendMessage = SendMessage
                .builder()
                .text(textToSend.substring(0, Math.min(textToSend.length(), 4095)))
                .chatId(chatId)
                .build();
        try {
            telegramClient.execute(sendMessage);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
        textToSend = textToSend.substring(Math.min(textToSend.length(), 4096), textToSend.length() - 1);
        while (textToSend.length() > 4096) {
            SendMessage newSendMessage = SendMessage
                    .builder()
                    .text(textToSend.substring(0, 4095))
                    .chatId(chatId)
                    .build();
            try {
                telegramClient.execute(newSendMessage);
            } catch (TelegramApiException e) {
                e.printStackTrace();
            }
            textToSend = textToSend.substring(4096, textToSend.length() - 1);
        }

    }
}
package tg.configshop.telegram.commands.impl;

import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.telegram.commands.Command;
import tg.configshop.constants.CommandName;


@Component
public class UnknownCommand implements Command {
    private CommandName commandName = CommandName.UNKNOWN;

    @Override
    public CommandName getCommand() {
        return commandName;
    }

    @Override
    public void handleCommand(Message message, TelegramClient telegramClient) {
        SendMessage sendMessage = SendMessage
                .builder()
                .text("")
                .build();
    }
}
package tg.configshop.telegram.commands.impl;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.methods.send.SendPhoto;
import org.telegram.telegrambots.meta.api.objects.InputFile;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.api.objects.photo.PhotoSize;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.exceptions.TelegramApiRequestException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.aop.AdminOnly;
import tg.configshop.constants.CommandName;
import tg.configshop.constants.MessageText;
import tg.configshop.model.BotUser;
import tg.configshop.services.UserService;
import tg.configshop.telegram.commands.Command;

import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Component
@RequiredArgsConstructor
public class BroadcastCommand implements Command {
    private final UserService userService;
    private final Semaphore rateLimiter = new Semaphore(25);

    @Override
    public CommandName getCommand() {
        return CommandName.BROADCAST;
    }

    @Override
    @AdminOnly
    public void handleCommand(Message message, TelegramClient telegramClient) {
        String fullText = message.hasText() ? message.getText() : message.getCaption();

        if (fullText == null) {
            sendError(message.getChatId(), MessageText.BROADCAST_TEXT_NOT_FOUND.getMessageText(), telegramClient);
            return;
        }

        String htmlText = extractTextAfterCommand(fullText);

        if (htmlText.isEmpty()) {
            String errorMsg = String.format(MessageText.BROADCAST_USAGE.getMessageText(),
                    CommandName.BROADCAST.getCommandName());
            sendError(message.getChatId(), errorMsg, telegramClient);
            return;
        }

        String photoFileId = null;
        if (message.hasPhoto()) {
            List<PhotoSize> photos = message.getPhoto();
            photoFileId = photos.getLast().getFileId();
        }

        List<BotUser> allUsers = userService.getAllUsers();

        if (allUsers.isEmpty()) {
            sendError(message.getChatId(), MessageText.BROADCAST_NO_USERS.getMessageText(), telegramClient);
            return;
        }

        sendConfirmation(message.getChatId(),
                String.format(MessageText.BROADCAST_START.getMessageText(), allUsers.size()),
                telegramClient);


        AtomicInteger sent = new AtomicInteger(0);
        AtomicInteger failed = new AtomicInteger(0);
        AtomicInteger blocked = new AtomicInteger(0);

        final String finalPhotoFileId = photoFileId;


        for (BotUser user : allUsers) {
            Thread.startVirtualThread(() -> {
                try {
                    rateLimiter.acquire();

                    if (finalPhotoFileId != null) {
                        sendPhotoWithRetry(user.getId(), htmlText, finalPhotoFileId, telegramClient);
                    } else {
                        sendMessageWithRetry(user.getId(), htmlText, telegramClient);
                    }

                    sent.incrementAndGet();

                } catch (TelegramApiRequestException e) {
                    if (e.getErrorCode() == 403) {
                        blocked.incrementAndGet();
                        log.debug("User {} blocked the bot", user.getId());
                    } else {
                        failed.incrementAndGet();
                        log.error("Failed to send to user {}: {}", user.getId(), e.getMessage());
                    }
                } catch (Exception e) {
                    failed.incrementAndGet();
                    log.error("Unexpected error for user {}: {}", user.getId(), e.getMessage());
                } finally {
                    rateLimiter.release();
                }

                int total = sent.get() + failed.get() + blocked.get();
                if (total % 100 == 0) {
                    log.info("Broadcast Progress: {}/{}", total, allUsers.size());
                }
            });

            try {
                Thread.sleep(5);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }


        Thread.startVirtualThread(() -> {
            try {

                Thread.sleep(15000);
                String report = String.format(
                        MessageText.BROADCAST_REPORT.getMessageText(),
                        sent.get(), failed.get(), blocked.get()
                );
                sendConfirmation(message.getChatId(), report, telegramClient);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
    }



    private void sendMessageWithRetry(Long chatId, String htmlText, TelegramClient telegramClient)
            throws TelegramApiException {
        SendMessage sendMessage = SendMessage.builder()
                .chatId(chatId)
                .text(htmlText)
                .parseMode("HTML")
                .build();

        executeWithRetry(() -> telegramClient.execute(sendMessage));
    }

    private void sendPhotoWithRetry(Long chatId, String caption, String photoFileId,
                                    TelegramClient telegramClient) throws TelegramApiException {
        SendPhoto sendPhoto = SendPhoto.builder()
                .chatId(chatId)
                .photo(new InputFile(photoFileId))
                .caption(caption)
                .parseMode("HTML")
                .build();

        executeWithRetry(() -> telegramClient.execute(sendPhoto));
    }

    private void executeWithRetry(ThrowingSupplier action) throws TelegramApiException {
        int maxRetries = 3;
        int attempt = 0;

        while (attempt < maxRetries) {
            try {
                action.execute();
                return;
            } catch (TelegramApiRequestException e) {
                if (e.getErrorCode() == 429) {
                    Integer retryAfter = extractRetryAfter(e);
                    log.warn("Rate limit hit, waiting {} seconds...", retryAfter);

                    try {
                        Thread.sleep(retryAfter * 1000L);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw e;
                    }
                    attempt++;
                } else {
                    throw e;
                }
            }
        }
        throw new TelegramApiException("Failed after " + maxRetries + " retries");
    }

    private Integer extractRetryAfter(TelegramApiRequestException e) {
        if (e.getParameters() != null && e.getParameters().getRetryAfter() != null) {
            return e.getParameters().getRetryAfter();
        }
        Pattern pattern = Pattern.compile("retry after (\\d+)");
        Matcher matcher = pattern.matcher(e.getMessage().toLowerCase());
        if (matcher.find()) {
            return Integer.parseInt(matcher.group(1));
        }
        return 5;
    }

    private String extractTextAfterCommand(String messageText) {
        String[] parts = messageText.split(" ", 2);
        return parts.length > 1 ? parts[1].trim() : "";
    }

    private void sendError(Long chatId, String text, TelegramClient telegramClient) {
        SendMessage sendMessage = SendMessage.builder()
                .chatId(chatId)
                .text(text)
                .build();
        try {
            telegramClient.execute(sendMessage);
        } catch (TelegramApiException e) {
            log.error("Failed to send error message: {}", e.getMessage());
        }
    }

    private void sendConfirmation(Long chatId, String text, TelegramClient telegramClient) {
        SendMessage sendMessage = SendMessage.builder()
                .chatId(chatId)
                .text(text)
                .build();
        try {
            telegramClient.execute(sendMessage);
        } catch (TelegramApiException e) {
            log.error("Failed to send confirmation: {}", e.getMessage());
        }
    }

    @FunctionalInterface
    private interface ThrowingSupplier {
        void execute() throws TelegramApiException;
    }
}
package tg.configshop.telegram.commands;


import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.CommandName;


public interface Command {
    CommandName getCommand ();
    void handleCommand(Message message, TelegramClient telegramClient);
}
package tg.configshop.telegram.containers;

import com.google.common.collect.ImmutableMap;
import org.springframework.stereotype.Component;
import tg.configshop.telegram.callbacks.Callback;

import java.util.HashMap;
import java.util.List;

@Component
public class CallbackContainer {
    private final ImmutableMap<String, Callback> callbacks;

    public CallbackContainer(List<Callback> callbackList) {
        HashMap<String, Callback> map = new HashMap<>();
        for (Callback callback : callbackList) {
            map.put(callback.getCallback().getCallbackName(), callback);
        }
        callbacks = ImmutableMap.copyOf(map);
    }

    public Callback retrieveCallback(String callbackIdentifier) {
        return callbacks.get(callbackIdentifier);
    }
}
package tg.configshop.telegram.containers;

import com.google.common.collect.ImmutableMap;
import org.springframework.stereotype.Component;
import tg.configshop.telegram.commands.Command;
import tg.configshop.telegram.commands.impl.UnknownCommand;

import java.util.HashMap;
import java.util.List;

@Component
public class CommandContainer {
    private final ImmutableMap<String, Command> commands;
    private final Command unknownCommand;

    public CommandContainer(List<Command> commandList) {
        HashMap<String, Command> map = new HashMap<String, Command>();
        for (Command command : commandList) {
            map.put(command.getCommand().getCommandName(), command);
        }
        commands = ImmutableMap.copyOf(map);
        unknownCommand = new UnknownCommand();
    }

    public Command retrieveCommand(String commandIdentifier) {
        return commands.getOrDefault(commandIdentifier, unknownCommand);
    }
}
package tg.configshop.telegram.containers;

import com.google.common.collect.ImmutableMap;
import org.springframework.stereotype.Component;
import tg.configshop.telegram.dialogstages.DialogStage;

import java.util.HashMap;
import java.util.List;


@Component
public class DialogStateContainer {
    private final ImmutableMap<String, DialogStage> dialogStages;

    public DialogStateContainer(List<DialogStage> dialogStageList) {
        HashMap<String, DialogStage> map = new HashMap<>();
        for (DialogStage dialogStage : dialogStageList) {
            map.put(dialogStage.getDialogStage().getDialogStageName(), dialogStage);
        }
        dialogStages = ImmutableMap.copyOf(map);
    }

    public DialogStage retrieveDialogStage (String dialogStageIdentifier) {
        return dialogStages.get(dialogStageIdentifier);
    }

}
package tg.configshop.telegram.handlers.impl;

import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.telegram.config.TelegramConfig;
import tg.configshop.repositories.UserStateRepository;
import tg.configshop.constants.DialogStageName;
import tg.configshop.telegram.containers.CommandContainer;
import tg.configshop.telegram.containers.DialogStateContainer;
import tg.configshop.telegram.handlers.MessageHandler;

@AllArgsConstructor
@Component
public class MessageHandlerImpl implements MessageHandler {

    private final CommandContainer commandContainer;

    private final TelegramConfig telegramConfig;

    private final UserStateRepository userStateRepository;

    private final DialogStateContainer dialogStateContainer;

    @Override
    public void answerMessage(Message message, TelegramClient telegramClient) {
        DialogStageName stage = userStateRepository.get(message.getFrom().getId());

        if (!stage.equals(DialogStageName.NONE)) {
            dialogStateContainer.retrieveDialogStage(stage.getDialogStageName())
                    .answerMessage(message, telegramClient);
        } else {
            boolean hasText = message.hasText();
            boolean hasCaption = message.hasCaption();

            if (hasText || hasCaption) {
                String text = hasText ? message.getText() : message.getCaption();

                if (text.startsWith("/")) {
                    String commandIdentifier = text.split(" ")[0]
                            .split("\n")[0]
                            .split(telegramConfig.getBotName())[0]
                            .toLowerCase();

                    commandContainer.retrieveCommand(commandIdentifier)
                            .handleCommand(message, telegramClient);
                }
            }
        }
    }
}
package tg.configshop.telegram.handlers.impl;

import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.repositories.UserStateRepository;
import tg.configshop.constants.DialogStageName;
import tg.configshop.telegram.containers.CallbackContainer;
import tg.configshop.telegram.containers.DialogStateContainer;
import tg.configshop.telegram.handlers.CallbackQueryHandler;

@AllArgsConstructor
@Component
public class CallbackQueryHandlerImpl implements CallbackQueryHandler {
    private final CallbackContainer callbackContainer;

    private final UserStateRepository userStateRepository;

    private final DialogStateContainer dialogStateContainer;

    @Override
    public void processCallbackQuery(CallbackQuery callbackQuery, TelegramClient telegramClient) {
//        Long userAllowId = Long.parseLong(callbackQuery.getData().split(":")[1]);
        Long userCallbackId = callbackQuery.getFrom().getId();
//        if (!userAllowId.equals(userCallbackId)) {
//            return;
//        }
        DialogStageName stage = userStateRepository.get(userCallbackId);
        if (!stage.equals(DialogStageName.NONE)) {
            dialogStateContainer.retrieveDialogStage(stage.getDialogStageName()).processCallbackQuery(callbackQuery, telegramClient);
            return;
        }
        String callbackIdentifier = callbackQuery.getData().split(":")[0];
        callbackContainer.retrieveCallback(callbackIdentifier).processCallback(callbackQuery, telegramClient);
    }
}
package tg.configshop.telegram.handlers;

import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
import org.telegram.telegrambots.meta.generics.TelegramClient;



public interface CallbackQueryHandler {
    void processCallbackQuery(CallbackQuery callbackQuery, TelegramClient telegramClient);
}
package tg.configshop.telegram.handlers;


import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.generics.TelegramClient;


public interface MessageHandler {
    void answerMessage(Message message, TelegramClient telegramClient);
}
package tg.configshop.model;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.Instant;

@Entity
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "purchases")
public class Purchase {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private Long paidAmount;
    @ManyToOne
    @JoinColumn(name = "subscription_id")
    private Subscription subscription;
    @ManyToOne
    @JoinColumn(name = "bot_user_id")
    private BotUser botUser;
    @Builder.Default
    private Instant createdAt = Instant.now();
}
package tg.configshop.model;


import io.hypersistence.tsid.TSID;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import tg.configshop.constants.WithdrawalStatus;
import tg.configshop.constants.WithdrawalType;

import java.time.Instant;

@Entity
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "withdrawals")
public class Withdrawal {
    @Id
    @Builder.Default
    private Long id = TSID.fast().toLong();
    @ManyToOne
    private BotUser botUser;
    @Builder.Default
    private Instant createdAt = Instant.now();
    private Long amount;
    @Enumerated(EnumType.STRING)
    @Builder.Default
    private WithdrawalStatus status = WithdrawalStatus.IN_PROGRESS;
    @Enumerated(EnumType.STRING)
    // CARD, CRYPTO
    private WithdrawalType type;
    private String requisites;

    public String getPublicId() {
        return TSID.from(id).toString();
    }
}
package tg.configshop.model;


import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.Instant;

@Entity
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "bot_users")
public class BotUser {
    @Id
    private Long id;
    @Column(name = "remnawave_uuid")
    private String remnawaveUuid;
    private String firstName;
    private String lastName;
    private String username;
    @Column(unique = true)
    private String shortId;
    @Column(nullable = false)
    @Builder.Default
    private Long balance = 0L;
    @Builder.Default
    private Integer referralPercentage1lvl = 35;
    @Builder.Default
    private Integer referralPercentage2lvl = 20;
    @Builder.Default
    private Integer referralPercentage3lvl = 10;
    private Instant expireAt;
    @Builder.Default
    private Instant createdAt = Instant.now();

}
package tg.configshop.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.Instant;

@Entity
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "referrals")
public class Referral {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne
    private BotUser referrer;
    @OneToOne
    @JoinColumn(unique = true)
    private BotUser referral;
    @Builder.Default
    private Instant createdAt = Instant.now();
}
package tg.configshop.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "promo_codes")
public class PromoCode {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(unique = true, nullable = false)
    private String code;
    private Long amount;
    private Integer maxUses;
    @Builder.Default
    private Integer currentUses = 0;
    @Builder.Default
    private Boolean isReferral = false;
    @ManyToOne
    private BotUser referrer;
}
package tg.configshop.model;

import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import tg.configshop.constants.TopUpSource;

import java.time.Instant;

@Entity
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "top_ups")
public class TopUp {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private Long value;
    // REFERRAL/CARD/PROMO_CODE
    @Enumerated(EnumType.STRING)
    private TopUpSource topUpSource;
    @Builder.Default
    private Instant createdAt = Instant.now();
    @ManyToOne
    private BotUser botUser;
    private String externalId;
    @ManyToOne
    private BotUser referral;

}
package tg.configshop.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import jakarta.persistence.UniqueConstraint;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "subscriptions", uniqueConstraints = {
        @UniqueConstraint(
                name = "uk_duration_device",
                columnNames = {"duration_days", "device_count"}
        )
})
public class Subscription {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(nullable = false)
    private Long cost;
    @Column(nullable = false)
    private String name;
    @Column(name = "duration_days", nullable = false)
    private Integer durationDays;
    private Integer trafficLimitGb;
    @Column(name = "device_count", nullable = false)
    private Integer deviceCount;
    @Column(columnDefinition = "TEXT")
    private String description;
}
package tg.configshop.model;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import jakarta.persistence.UniqueConstraint;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.Instant;

@Entity
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "promo_code_uses", uniqueConstraints = @UniqueConstraint(columnNames = {"promo_code_id", "bot_user_id"}))
public class PromoCodeUse {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne
    private PromoCode promoCode;
    @ManyToOne
    private BotUser botUser;
    @Builder.Default
    private Instant createdAt = Instant.now();
}
package tg.configshop.events;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public class ReferralRewardEvent {
    private final long referrerId;
    private final long sourceUserId;
    private final long rewardAmount;
    private final int level;
    private final long purchaseAmount;
    private final double percentage;
}
package tg.configshop.events;

import lombok.Getter;
import org.springframework.context.ApplicationEvent;
@Getter
public class PaymentConfirmedEvent extends ApplicationEvent {
    private final Long userId;
    private final Long amount;

    public PaymentConfirmedEvent(Object source, Long userId, Long amount) {
        super(source);
        this.userId = userId;
        this.amount = amount;
    }
}
package tg.configshop.events;

import lombok.Getter;
import org.springframework.context.ApplicationEvent;
@Getter
public class ReferralCreatedEvent extends ApplicationEvent {
    private final Long referrerId;
    private final Long referralId;

    public ReferralCreatedEvent(Object source, Long referrerId, Long referralId) {
        super(source);
        this.referrerId = referrerId;
        this.referralId = referralId;
    }
}
package tg.configshop.listeners;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.MessageText;
import tg.configshop.events.ReferralRewardEvent;

@Slf4j
@Component
@RequiredArgsConstructor
public class ReferralNotificationListener {

    private final TelegramClient telegramClient;

    @Async
    @EventListener
    public void handleRewardNotification(ReferralRewardEvent event) {

        String text = MessageText.REFERRAL_REWARD_NOTIFICATION.getMessageText().formatted(
                event.getLevel(),
                event.getPurchaseAmount(),
                event.getPercentage(),
                event.getRewardAmount()
        );

        SendMessage sendMessage = SendMessage.builder()
                .chatId(event.getReferrerId())
                .text(text)
                .parseMode("HTML")
                .build();

        try {
            telegramClient.execute(sendMessage);
            log.info("Referral reward notification sent to user {}", event.getReferrerId());
        } catch (TelegramApiException e) {
            log.error("Failed to send referral reward notification to user {}: {}", event.getReferrerId(), e.getMessage());
        }
    }
}
package tg.configshop.listeners;

import lombok.RequiredArgsConstructor;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import tg.configshop.constants.TopUpSource;
import tg.configshop.events.PaymentConfirmedEvent;
import tg.configshop.events.ReferralRewardEvent;
import tg.configshop.model.BotUser;
import tg.configshop.model.TopUp;
import tg.configshop.repositories.TopUpRepository;
import tg.configshop.services.ReferralService;
import tg.configshop.services.UserService;

import java.util.Optional;

@Component
@RequiredArgsConstructor
public class PaymentConfirmedListener {

    private final ReferralService referralService;
    private final UserService userService;
    private final TopUpRepository topUpRepository;
    private final ApplicationEventPublisher eventPublisher;

    private static final int MAX_REFERRAL_LEVELS = 3;

    @EventListener
    @Transactional
    public void handle(PaymentConfirmedEvent event) {
        long buyerId = event.getUserId();
        long purchaseAmount = event.getAmount();

        BotUser buyer = userService.getUser(buyerId);

        if (buyer == null) return;

        long currentIteratedUserId = buyerId;

        for (int level = 1; level <= MAX_REFERRAL_LEVELS; level++) {
            Optional<Long> referrerIdOpt = referralService.getReferrerId(currentIteratedUserId);

            if (referrerIdOpt.isEmpty()) {
                break;
            }

            Long referrerId = referrerIdOpt.get();
            BotUser referrer = userService.getUser(referrerId);

            if (referrer == null) {
                break;
            }

            double percentage = getPercentageForLevel(referrer, level);

            if (percentage > 0) {
                long reward = (long) (purchaseAmount * (percentage / 100.0));

                if (reward > 0) {
                    userService.addToBalance(referrerId, reward);

                    createAndSaveTopUp(referrer, buyer, reward);

                    eventPublisher.publishEvent(new ReferralRewardEvent(
                            referrerId,
                            buyerId,
                            reward,
                            level,
                            purchaseAmount,
                            percentage
                    ));
                }
            }
            currentIteratedUserId = referrerId;
        }
    }

    private void createAndSaveTopUp(BotUser beneficiary, BotUser sourceUser, long amount) {
        TopUp topUp = TopUp.builder()
                .botUser(beneficiary)
                .value(amount)
                .topUpSource(TopUpSource.REFERRAL)
                .referral(sourceUser)
                .build();

        topUpRepository.save(topUp);
    }

    private double getPercentageForLevel(BotUser user, int level) {
        return switch (level) {
            case 1 -> user.getReferralPercentage1lvl();
            case 2 -> user.getReferralPercentage2lvl();
            case 3 -> user.getReferralPercentage3lvl();
            default -> 0.0;
        };
    }
}
package tg.configshop.listeners;

import lombok.RequiredArgsConstructor;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;
import tg.configshop.constants.MessageText;
import tg.configshop.events.ReferralCreatedEvent;
import tg.configshop.model.BotUser;
import tg.configshop.services.UserService;
import tg.configshop.util.StringUtil;

@Component
@RequiredArgsConstructor
public class ReferralCreatedListener {
    private final TelegramClient telegramClient;
    private final UserService userService;

    @EventListener
    public void handle (ReferralCreatedEvent event) {
        BotUser botUser = userService.getUser(event.getReferralId());
        String safeName = StringUtil.getSafeHtmlString(botUser.getFirstName());
        String text = MessageText.REFERRAL_CREATED.getMessageText().formatted(botUser.getId(), safeName);
        SendMessage sendMessage = SendMessage.builder()
                .chatId(event.getReferrerId())
                .text(text)
                .parseMode("HTML")
                .build();
        try {
            telegramClient.execute(sendMessage);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }
}
package tg.configshop.services.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tg.configshop.constants.TopUpSource;
import tg.configshop.exceptions.promocode.CyclicReferralException;
import tg.configshop.exceptions.promocode.PromoCodeAlreadyUsedException;
import tg.configshop.exceptions.promocode.PromoCodeEndedException;
import tg.configshop.exceptions.promocode.PromoCodeNotFoundException;
import tg.configshop.exceptions.promocode.ReferralPromoCodeAlreadyUsedException;
import tg.configshop.exceptions.promocode.SelfReferralException;
import tg.configshop.model.BotUser;
import tg.configshop.model.PromoCode;
import tg.configshop.model.PromoCodeUse;
import tg.configshop.model.TopUp;
import tg.configshop.repositories.BotUserRepository;
import tg.configshop.repositories.PromoCodeRepository;
import tg.configshop.repositories.PromoCodeUseRepository;
import tg.configshop.repositories.ReferralRepository;
import tg.configshop.repositories.TopUpRepository;
import tg.configshop.services.PromoCodeService;
import tg.configshop.services.ReferralService;

import java.time.Instant;

@Service
@RequiredArgsConstructor
public class PromoCodeServiceImpl implements PromoCodeService {
    private final PromoCodeRepository promoCodeRepository;
    private final PromoCodeUseRepository promoCodeUseRepository;
    private final BotUserRepository botUserRepository;
    private final ReferralService referralService;
    private final TopUpRepository topUpRepository;
    private final ReferralRepository referralRepository;

    @Override
    @Transactional
    public void activatePromoCode(String code, Long userId) {
        PromoCode promoCode = getPromoCode(code);

        BotUser user = getBotUser(userId);

        checkReferralConditions(promoCode, user);

        checkBasicConditions(promoCode, user);

        usePromoCode(promoCode, user);

        setReferralIfPromoIsReferral(promoCode, user);

    }

    @Override
    @Transactional
    public void createPromoCode(PromoCode promoCode) {
        if (promoCodeRepository.findByCode(promoCode.getCode()).isPresent()) {
            throw new RuntimeException("–ü—Ä–æ–º–æ–∫–æ–¥ —Å —Ç–∞–∫–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç");
        }
        promoCodeRepository.save(promoCode);
    }

    private PromoCode getPromoCode (String code) {
        return promoCodeRepository.findByCodeWithLock(code)
                .orElseThrow(() -> new PromoCodeNotFoundException());
    }

    private BotUser getBotUser (Long userId) {
        return botUserRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω"));
    }



    private void checkReferralConditions(PromoCode promoCode, BotUser botUser) {
        if (promoCode.getIsReferral()) {
            BotUser promoOwner = promoCode.getReferrer();

            if (promoOwner != null && promoOwner.getId().equals(botUser.getId())) {
                throw new SelfReferralException();
            }

            if (promoCodeUseRepository.existsByBotUserAndPromoCode_IsReferralTrue(botUser)) {
                throw new ReferralPromoCodeAlreadyUsedException();
            }

            if (promoOwner != null) {
                boolean isCycle = referralRepository.isUserAncestorOf(botUser.getId(), promoOwner.getId());
                if (isCycle) {
                    throw new CyclicReferralException();
                }
            }
        }
    }

    private void checkBasicConditions(PromoCode promoCode, BotUser user) {
        if (promoCode.getMaxUses() != null && promoCode.getCurrentUses() >= promoCode.getMaxUses()) {
            throw new PromoCodeEndedException();
        }
        if (promoCodeUseRepository.existsByPromoCodeAndBotUser(promoCode, user)) {
            throw new PromoCodeAlreadyUsedException();
        }
    }

    private void setReferralIfPromoIsReferral (PromoCode promoCode, BotUser botUser) {
        if (promoCode.getIsReferral() && promoCode.getReferrer() != null) {
            referralService.createReferral(promoCode.getReferrer().getId(), botUser.getId());
        }
    }

    private void usePromoCode (PromoCode promoCode, BotUser user) {

        increaseUserBalance(promoCode, user);

        createTopUp(promoCode, user);

        increaseUseCountOfPromoCode(promoCode, user);

        createPromoCodeUsage(promoCode, user);

    }

    private void increaseUserBalance (PromoCode promoCode, BotUser user) {
        user.setBalance(user.getBalance() + promoCode.getAmount());
        botUserRepository.save(user);
    }

    private void createTopUp (PromoCode promoCode, BotUser user) {
        TopUp topUp = TopUp.builder()
                .botUser(user)
                .value(promoCode.getAmount())
                .topUpSource(TopUpSource.PROMO_CODE)
                .externalId(promoCode.getCode())
                .createdAt(Instant.now())
                .build();
        topUpRepository.save(topUp);
    }

    private void increaseUseCountOfPromoCode (PromoCode promoCode, BotUser user) {
        promoCode.setCurrentUses(promoCode.getCurrentUses() + 1);
        promoCodeRepository.save(promoCode);
    }

    private void createPromoCodeUsage (PromoCode promoCode, BotUser user) {
        PromoCodeUse usage = PromoCodeUse.builder()
                .promoCode(promoCode)
                .botUser(user)
                .createdAt(Instant.now())
                .build();
        promoCodeUseRepository.save(usage);
    }


}

package tg.configshop.services.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.telegram.telegrambots.meta.api.objects.User;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import tg.configshop.external_api.remnawave.RemnawaveClient;
import tg.configshop.external_api.remnawave.dto.user.RemnawaveUserResponse;
import tg.configshop.model.BotUser;
import tg.configshop.repositories.BotUserRepository;
import tg.configshop.services.ReferralService;
import tg.configshop.services.RegistrationService;
@Service
@RequiredArgsConstructor
public class RegistrationServiceImpl implements RegistrationService {
    private final BotUserRepository botUserRepository;
    private final ReferralService referralService;
    private final RemnawaveClient remnawaveClient;

    @Override
    public boolean isRegistered(Long userId) {
        return botUserRepository.findById(userId).orElse(null) != null;
    }

    @Override
    public BotUser registerUser(User user, Long referrerId) {
        RemnawaveUserResponse remnaUser = remnawaveClient.createBasicUser(user.getId().toString(), user.getId());
        BotUser botUser = BotUser
                .builder()
                .username(user.getUserName())
                .id(user.getId())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .remnawaveUuid(remnaUser.uuid())
                .shortId(remnaUser.shortUuid())
                .expireAt(remnaUser.expireAt())
                .build();
        botUserRepository.save(botUser);
        if (referrerId != null) {
            referralService.createReferral(referrerId, user.getId());
        }
        referralService.createReferralCode(user.getId());
        return botUser;
    }


}
package tg.configshop.services.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tg.configshop.constants.TopUpSource;
import tg.configshop.dto.ReferralView;
import tg.configshop.dto.ReferralWithProfit;
import tg.configshop.dto.ReferralWithProfitAndLevel;
import tg.configshop.events.ReferralCreatedEvent;
import tg.configshop.model.BotUser;
import tg.configshop.model.PromoCode;
import tg.configshop.model.Referral;
import tg.configshop.repositories.BotUserRepository;
import tg.configshop.repositories.PromoCodeRepository;
import tg.configshop.repositories.ReferralRepository;
import tg.configshop.repositories.TopUpRepository;
import tg.configshop.repositories.WithdrawalRepository;
import tg.configshop.services.ReferralService;

import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
// TODO decompose god-service
public class ReferralServiceImpl implements ReferralService {
    private final ReferralRepository referralRepository;
    private final BotUserRepository botUserRepository;
    private final PromoCodeRepository promoCodeRepository;
    private final TopUpRepository topUpRepository;
    private final ApplicationEventPublisher eventPublisher;


    private final WithdrawalRepository withdrawalRepository;

    private final String PROMO_CODE_PREFIX = "REF_";
    private final long REFERRAL_PROMO_CODE_BASE_AMOUNT = 100L;
    private final int REFERRAL_PAGE_SIZE = 15;

    @Override
    @Transactional
    public void createReferral(Long referrerId, Long referralId) {
        Optional<Referral> existingReferral = referralRepository.findByReferral_Id(referralId);

        if (existingReferral.isEmpty()) {
            referralRepository.save(Referral
                    .builder()
                    .referrer(botUserRepository.getReferenceById(referrerId))
                    .referral(botUserRepository.getReferenceById(referralId))
                    .build());
            eventPublisher.publishEvent(new ReferralCreatedEvent(this, referrerId, referralId));
        }
    }

    @Override
    public void createReferralCode(Long userId) {
        promoCodeRepository.save(PromoCode
                .builder()
                .code(PROMO_CODE_PREFIX + userId)
                .isReferral(true)
                .amount(REFERRAL_PROMO_CODE_BASE_AMOUNT)
                .maxUses(1000)
                .referrer(botUserRepository.getReferenceById(userId))
                .build()
        );
    }

    @Override
    public int getAllReferralCount(Long userId) {
        return referralRepository.countReferralsByReferrer_Id(userId);
    }

    @Override
    public int getActiveReferralCount(Long userId) {
        return referralRepository.countActiveReferrals(userId, Instant.now());
    }

    @Override
    public long getAllProfit(Long userId) {
        return topUpRepository.getSumByUserIdAndSource(userId, TopUpSource.REFERRAL);
    }

    @Override
    public String getReferralPromoCode(Long userId) {
        return promoCodeRepository.findAllByReferrer(botUserRepository.getReferenceById(userId)).get(0).getCode();
    }

    @Override
    public Long getAvailableSumToWithdraw(Long userId) {
        Long totalReferralEarnings = topUpRepository.getSumByUserIdAndSource(userId, TopUpSource.REFERRAL);
        Long totalWithdrawnOrPending = withdrawalRepository.sumConsumedReferralBalance(userId);
        long theoreticalReferralBalance = Math.max(0, totalReferralEarnings - totalWithdrawnOrPending);

        Long currentWalletBalance = botUserRepository.findById(userId)
                .map(BotUser::getBalance)
                .orElse(0L);
        return Math.min(theoreticalReferralBalance, currentWalletBalance);
    }

    @Override
    public Page<ReferralWithProfitAndLevel> getReferralsWithProfitAndLevel(Long userId, int pageNumber) {
        Pageable pageable = PageRequest.of(pageNumber, REFERRAL_PAGE_SIZE);

        Page<ReferralView> viewPage = referralRepository.findReferralsProjection(userId, pageable);

        return viewPage.map(view -> {
            BotUser tempUser = BotUser.builder()
                    .id(view.getUserId())
                    .firstName(view.getFirstName())
                    .expireAt(view.getExpireAt())
                    .build();

            return new ReferralWithProfitAndLevel(
                    tempUser,
                    view.getProfit(),
                    view.getReferredAt(),
                    view.getLvl()
            );
        });
    }

    @Override
    public Optional<Long> getReferrerId(Long userId) {
        Referral referral = referralRepository.findByReferral_Id(userId).orElse(null);
        if (referral != null) {
            return Optional.of(referral.getReferrer().getId());
        }
        return Optional.empty();
    }
}
package tg.configshop.services.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tg.configshop.exceptions.subscription.InsufficientBalanceException;
import tg.configshop.exceptions.subscription.SubscriptionNotFoundException;
import tg.configshop.external_api.remnawave.RemnawaveClient;
import tg.configshop.model.BotUser;
import tg.configshop.model.Purchase;
import tg.configshop.model.Subscription;
import tg.configshop.repositories.PurchaseRepository;
import tg.configshop.repositories.SubscriptionRepository;
import tg.configshop.services.SubscriptionService;
import tg.configshop.services.UserService;

import java.time.Instant;

@Service
@RequiredArgsConstructor
public class SubscriptionServiceImpl implements SubscriptionService {
    private final SubscriptionRepository subscriptionRepository;
    private final UserService userService;
    private final RemnawaveClient remnawaveClient;
    private final PurchaseRepository purchaseRepository;
    @Value("${MIN_DEVICE_COUNT}")
    private int MIN_DEVICE_COUNT;

    @Value("${MAX_DEVICE_COUNT}")
    private int MAX_DEVICE_COUNT;

    @Value("${BASE_PRICE_FOR_1_MONTH}")
    private int BASE_PRICE_FOR_1_MONTH;

    @Value("${BASE_PRICE_FOR_3_MONTH}")
    private int BASE_PRICE_FOR_3_MONTH;

    @Value("${BASE_PRICE_FOR_6_MONTH}")
    private int BASE_PRICE_FOR_6_MONTH;

    @Value("${BASE_PRICE_FOR_12_MONTH}")
    private int BASE_PRICE_FOR_12_MONTH;

    @Value("${EXTRA_PER_DEVICE_1_MONTH}")
    private int EXTRA_PER_DEVICE_1_MONTH;

    @Value("${EXTRA_PER_DEVICE_3_MONTH}")
    private int EXTRA_PER_DEVICE_3_MONTH;

    @Value("${EXTRA_PER_DEVICE_6_MONTH}")
    private int EXTRA_PER_DEVICE_6_MONTH;

    @Value("${EXTRA_PER_DEVICE_12_MONTH}")
    private int EXTRA_PER_DEVICE_12_MONTH;

    @Value("${TRAFFIC_LIMIT_PER_DEVICE}")
    private int TRAFFIC_LIMIT_PER_DEVICE;

    @Override
    @Transactional
    public void buySubscription(Long userId, Long subscriptionId) throws InsufficientBalanceException {
        BotUser botUser = userService.getUser(userId);
        Subscription subscription = subscriptionRepository.findById(subscriptionId).orElseThrow();
        checkBalance(botUser, subscription);

        Instant newExpired = getNewExpired(botUser, subscription);

        updateUser(botUser, subscription, newExpired);

        updateSubscription(botUser, subscription, newExpired);

        savePurchase(botUser, subscription);

    }

    private void checkBalance(BotUser botUser, Subscription subscription) {
        if (botUser.getBalance() < subscription.getCost()) {
            throw new InsufficientBalanceException();
        }
    }

    private void updateUser (BotUser botUser, Subscription subscription, Instant newExpired) {
        botUser.setBalance(botUser.getBalance() - subscription.getCost());
        botUser.setExpireAt(newExpired);
    }

    private Instant getNewExpired (BotUser botUser, Subscription subscription) {
        long durationSeconds = subscription.getDurationDays() * 24 * 60 * 60;
        if (botUser.getExpireAt().isBefore(Instant.now())) {
            return Instant.now().plusSeconds(durationSeconds);
        } else {
            return botUser.getExpireAt().plusSeconds(durationSeconds);
        }
    }

    private void updateSubscription (BotUser botUser, Subscription subscription, Instant newExpired) {
        remnawaveClient.updateSubscription(botUser.getRemnawaveUuid(), newExpired, subscription.getTrafficLimitGb() * 1024L * 1024 * 1024, subscription.getDeviceCount());
    }

    private void savePurchase(BotUser botUser, Subscription subscription) {
        purchaseRepository.save(Purchase.builder()
                .botUser(botUser)
                .subscription(subscription)
                .createdAt(Instant.now())
                .paidAmount(subscription.getCost())
                .build());
    }

    @Override
    public Subscription getSubscriptionByDaysAndDevices(int days, int devices) throws SubscriptionNotFoundException {
        return subscriptionRepository.findByDurationDaysAndDeviceCount(days, devices).orElseThrow(SubscriptionNotFoundException::new);
    }

    @Override
    public int getBaseSubscriptionCostByDays(int days) {
        return switch (days) {
            case 30 -> BASE_PRICE_FOR_1_MONTH;
            case 90 -> BASE_PRICE_FOR_3_MONTH;
            case 180 -> BASE_PRICE_FOR_6_MONTH;
            case 360 -> BASE_PRICE_FOR_12_MONTH;
            default -> throw new SubscriptionNotFoundException(
                    "–ë–∞–∑–æ–≤–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–ª—è –ø–µ—Ä–∏–æ–¥–∞ –≤ " + days + " –¥–Ω–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏."
            );
        };
    }

    @Override
    public int getMinDeviceCount() {
        return MIN_DEVICE_COUNT;
    }

    @Override
    public int getMaxDeviceCount() {
        return MAX_DEVICE_COUNT;
    }

    @Override
    public int getExtraPricePerDeviceByDays(int days) {
        return switch (days) {
            case 30 -> EXTRA_PER_DEVICE_1_MONTH;
            case 90 -> EXTRA_PER_DEVICE_3_MONTH;
            case 180 -> EXTRA_PER_DEVICE_6_MONTH;
            case 360 -> EXTRA_PER_DEVICE_12_MONTH;
            default -> throw new SubscriptionNotFoundException(
                    "–°—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ–ø. —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –¥–ª—è –ø–µ—Ä–∏–æ–¥–∞ –≤ " + days + " –¥–Ω–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏."
            );
        };
    }

    @Override
    public int getTrafficLimitPerDevice() {
        return TRAFFIC_LIMIT_PER_DEVICE;
    }
}
package tg.configshop.services.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tg.configshop.external_api.remnawave.dto.user.RemnawaveUserResponse;
import tg.configshop.model.BotUser;
import tg.configshop.repositories.BotUserRepository;
import tg.configshop.services.UserService;

import java.util.List;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {
    private final BotUserRepository botUserRepository;

    @Override
    public BotUser getUser(Long userId) {
        return botUserRepository.findById(userId).orElse(null);
    }

    @Override
    public List<BotUser> getUser(String username) {
        return botUserRepository.findByUsernameIgnoreCase(username);
    }

    @Override
    public List<BotUser> getAllUsers() {
        return botUserRepository.findAll();
    }

    @Override
    public void syncRemnawaveUserWithLocalUser(RemnawaveUserResponse userResponse, BotUser botUser) {
        botUser.setExpireAt(userResponse.expireAt());
        botUserRepository.save(botUser);
    }

    @Override
    @Transactional
    public void addToBalance(Long userId, Long amountToAdd) {
        BotUser user = botUserRepository.findByIdWithLock(userId)
                .orElseThrow(() -> new RuntimeException("User not found: " + userId));
        user.setBalance(user.getBalance() + amountToAdd);
        botUserRepository.save(user);
    }
}
package tg.configshop.services.impl;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tg.configshop.constants.MessageText;
import tg.configshop.constants.PaymentResult;
import tg.configshop.constants.TopUpSource;
import tg.configshop.events.PaymentConfirmedEvent;
import tg.configshop.external_api.pay.PlategaClient;
import tg.configshop.external_api.pay.constants.PaymentStatus;
import tg.configshop.external_api.pay.dto.CreatePaymentRequest;
import tg.configshop.external_api.pay.dto.CreatePaymentResponse;
import tg.configshop.external_api.pay.dto.PaymentDetails;
import tg.configshop.external_api.pay.model.PlategaPayment;
import tg.configshop.external_api.pay.repositories.PlategaPaymentRepository;
import tg.configshop.model.TopUp;
import tg.configshop.repositories.TopUpRepository;
import tg.configshop.services.PaymentService;
import tg.configshop.services.UserService;

@Slf4j
@Service
@RequiredArgsConstructor
public class PaymentServiceImpl implements PaymentService {
    private final PlategaClient plategaClient;
    private final PlategaPaymentRepository paymentRepository;
    private final UserService userService;
    private final TopUpRepository topUpRepository;
    private final ApplicationEventPublisher applicationEventPublisher;

    @Value("${TELEGRAM_BOT_USERNAME}")
    private String telegramBotUsername;

    @Override
    public PlategaPayment createPlategaPayment(Long amount, int paymentMethodInt, Long userId) {
        CreatePaymentRequest createPaymentRequest = new CreatePaymentRequest(
                paymentMethodInt,
                new PaymentDetails(amount.doubleValue(), "RUB"),
                MessageText.PAYMENT_DESCRIPTION.getMessageText().formatted(userId),
                "https://t.me/" + telegramBotUsername,
                "https://t.me/" + telegramBotUsername,
                "...");
        CreatePaymentResponse createPaymentResponse = plategaClient.createPayment(createPaymentRequest);
        PlategaPayment plategaPayment = PlategaPayment
                .builder()
                .paymentDetails(createPaymentResponse.paymentDetails())
                .amount(Double.parseDouble(createPaymentResponse.paymentDetails().split(" ")[0]))
                .currency(createPaymentResponse.paymentDetails().split(" ")[1])
                .status(createPaymentResponse.status())
                .paymentMethod(createPaymentResponse.paymentMethod())
                .cryptoAmount(createPaymentResponse.cryptoAmount())
                .redirect(createPaymentResponse.redirect())
                .returnUrl(createPaymentResponse.returnUrl())
                .transactionId(createPaymentResponse.transactionId())
                .usdtRate(createPaymentResponse.usdtRate())
                .build();
        paymentRepository.save(plategaPayment);
        return plategaPayment;
    }

    @Override
    @Transactional
    public PaymentResult checkPayment(String paymentId, Long userId) {
        PlategaPayment payment = paymentRepository.findByIdWithLock(paymentId)
                .orElseThrow(() -> new RuntimeException("Payment not found"));


        if (!PaymentStatus.PENDING.equals(payment.getStatus())) {
            return PaymentResult.EXPIRED;
        }

        PaymentStatus remoteStatus;
        try {
            // TODO remove HTTP-request from @Transactional
            remoteStatus = plategaClient.updateStatus(paymentId);
        } catch (Exception e) {
            log.error("Error fetching status from Platega", e);
            return PaymentResult.PROCESSING;
        }

        if (payment.getStatus() != remoteStatus) {
            payment.setStatus(remoteStatus);
            paymentRepository.save(payment);

            if (remoteStatus == PaymentStatus.CONFIRMED) {
                Long amount = payment.getAmount().longValue();

                userService.addToBalance(userId, amount);
                saveTopUpHistory(userId, amount, paymentId);
                applicationEventPublisher.publishEvent(new PaymentConfirmedEvent(this, userId, amount));

                return PaymentResult.CONFIRMED;
            } else if (remoteStatus == PaymentStatus.CANCELED) {
                return PaymentResult.CANCELED;
            }
        }
        return PaymentResult.PROCESSING;
    }

    private void saveTopUpHistory(Long userId, Long amount, String externalId) {
        TopUp topUp = TopUp.builder()
                .botUser(userService.getUser(userId))
                .value(amount)
                .topUpSource(TopUpSource.EXTERNAL)
                .externalId(externalId)
                .build();
        topUpRepository.save(topUp);
    }
}
package tg.configshop.services;

import tg.configshop.model.TopUp;

public interface BalanceService {
}
package tg.configshop.services;

import org.telegram.telegrambots.meta.api.objects.User;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import tg.configshop.model.BotUser;

public interface RegistrationService {
    boolean isRegistered (Long userId);
    BotUser registerUser (User user, Long referrerId);

}
package tg.configshop.services;

import tg.configshop.external_api.remnawave.dto.user.RemnawaveUserResponse;
import tg.configshop.model.BotUser;

import java.util.List;

public interface UserService {
    BotUser getUser (Long userId);
    List<BotUser> getUser (String username);
    void addToBalance(Long userId, Long amountToAdd);
    void syncRemnawaveUserWithLocalUser (RemnawaveUserResponse userResponse, BotUser botUser);
    List<BotUser> getAllUsers();
}
package tg.configshop.services;

import tg.configshop.exceptions.promocode.PromoCodeAlreadyUsedException;
import tg.configshop.exceptions.promocode.PromoCodeEndedException;
import tg.configshop.exceptions.promocode.PromoCodeNotFoundException;
import tg.configshop.exceptions.promocode.ReferralPromoCodeAlreadyUsedException;
import tg.configshop.model.PromoCode;

public interface PromoCodeService {
    void activatePromoCode (String code, Long userId) throws PromoCodeAlreadyUsedException, PromoCodeEndedException, PromoCodeNotFoundException, ReferralPromoCodeAlreadyUsedException;
    void createPromoCode (PromoCode promoCode);

}
package tg.configshop.services;

import org.springframework.data.domain.Page;
import tg.configshop.dto.ReferralWithProfit;
import tg.configshop.dto.ReferralWithProfitAndLevel;
import tg.configshop.model.BotUser;
import tg.configshop.model.Referral;

import java.util.List;
import java.util.Optional;

public interface ReferralService {
    void createReferral (Long referrerId, Long referralId);
    void createReferralCode (Long userId);
    int getAllReferralCount (Long userId);
    int getActiveReferralCount (Long userId);
    long getAllProfit (Long userId);
    String getReferralPromoCode (Long userId);
    Optional<Long> getReferrerId (Long userId);
    Long getAvailableSumToWithdraw(Long userId);
    Page<ReferralWithProfitAndLevel> getReferralsWithProfitAndLevel (Long userId, int pageNumber);


}
package tg.configshop.services;

import tg.configshop.constants.PaymentResult;
import tg.configshop.external_api.pay.model.PlategaPayment;

public interface PaymentService {

    PaymentResult checkPayment(String paymentId, Long userId);

    PlategaPayment createPlategaPayment (Long amount, int paymentMethodInt, Long userId);
}
package tg.configshop.services;

import tg.configshop.exceptions.subscription.InsufficientBalanceException;
import tg.configshop.exceptions.subscription.SubscriptionNotFoundException;
import tg.configshop.model.Subscription;

public interface SubscriptionService {
    int getBaseSubscriptionCostByDays (int days) throws SubscriptionNotFoundException;
    int getMinDeviceCount ();
    int getMaxDeviceCount ();
    int getExtraPricePerDeviceByDays (int days) throws SubscriptionNotFoundException;
    int getTrafficLimitPerDevice ();
    void buySubscription(Long userId, Long subscriptionId) throws InsufficientBalanceException;
    Subscription getSubscriptionByDaysAndDevices (int days, int devices) throws SubscriptionNotFoundException;
}
